1. 原始类型有哪几种？null 是对象吗？

原始类型存储的都是值，没有函数可以调用。包括：`undefined`、`string`、`number`、`boolean`、`symbol`、`null`

`typeof null` 等于 `object`。为了性能考虑使用低位存储变量的类型信息，`000` 开头代表是对象，然后 `null` 全为零。

2. 对象类型和原始类型的不同之处？函数参数是对象会发生什么问题？

原始类型存储的是值，对象类型存储的是地址（指针）。

当将变量赋值给另外一个变量时，复制的是原本变量的地址。

3. typeof 是否能正确判断类型？instanceof 的原理？

对于原始值来说，除了 `null` 都可以显示正确的类型

instanceof 内部是通过原型链(__proto__)来判断的

`Symbol.hasInstance` 是一个能让我们自定义 `instanceof` 的东西

```js
class PrimitiveString {
  static [Symbol.hasInstance](x) {
    return typeof x === 'string'
  }
}
console.log('hello world' instanceof PrimitiveString) // true
```

4. 类型转换（笔试题）

类型转换只有三种情况，分别是：

- 转换为布尔值

- 转换为数字

- 转换为字符串

转 `Boolean`：除了 `undefined`、`null`、 `0`、`false`、`NaN`、`''`，其他都转为 `true`

转原始类型：

- 已经是原始类型，无需转换

- 需要转字符串就调用 `toString()`，转换为基础类型就返回转换的值。不是字符串类型就先调用 `valueOf()`，再调用 `toString()`

- 调用 `valueOf()`，如果转换为基础类型，就返回

- 都没有返回原始类型，报错

可以重写 `Symbol.toPrimitive`，该方法在转原始类型时调用优先级最高

```js
let a = {
  valueOf() {
    return 0
  },
  toString() {
    return '1'
  },
  [Symbol.toPrimitive]() {
    return 2
  }
}
1 + a // => 3
```

加法运算符两方如果其中一方为字符串，会把另一方也转换成字符串。如果一方不是字符串或数字，那么会将它转换为数字或者字符串

```js
1 + '1' // '11'
true + true // 2
4 + [1,2,3] // "41,2,3"
'a' + + 'b' // "aNaN" 先执行 + 'b'
```

除了加法的运算符，只要其中一方是数字，那么另一方会被转为数字

比较运算符中，如果是对象，就通过 `toPrimitive` 转换对象。如果是字符串，通过 `unicode` 比较

```js
let a = {
  valueOf() {
    return 0
  },
  toString() {
    return '1'
  }
}
a > -1 // true 调用 valueOf
```

5. 如何正确判断 this？箭头函数的 this 是什么？

`new` 构造函数方式：`this` 固化在实例上

普通函数调用：谁调用函数，`this` 就指向谁

箭头函数的 `this` 只取决于包裹箭头函数的第一个普通函数的 `this`。对箭头函数使用 `bind` 这类函数是无效的

函数调用多次 `bind` 后最终返回的函数的 `this` 永远由第一次 `bind` 决定

```js
// fn.bind().bind(a) 等于
let fn2 = function fn1() {
  return function() {
    return fn.apply()
  }.apply(a)
}
fn2()
```

6. == 和 === 的区别？

`==` 在对方类型不一致的情况下回进行类型转换

- 判断类型是否相同，相同则比较大小

- 类型不同，进行类型转换

- 判断是否在比较 `null` 和 `undefined`，是则返回 `true`

- 判断两者类型是否为 `string` 和 `number`，是的话就将字符串转换为 `number`

- 判断其中一方是否为 `boolean`，是的话就把 `boolean` 转为 `number` 再进行判断

- 判断其中一方是否为 `object`，且另一方为 `string`、`number` 或者 `symbol`，是的话将 `object` 转为原始类型

`===` 判断两者类型和值是否相同

7. 什么是闭包？

函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包。

```js
function A() {
  let a = 1
  window.B = function () {
      console.log(a)
  }
}
A()
B() // 1
```

闭包存在的意义就是让我们可以间接访问函数内部的变量

8. 闭包面试题：第1秒输出1，第2秒输出2，...

```js
for (var i = 1; i <= 5; i++) {
  setTimeout(function timer() {
    console.log(i)
  }, i * 1000)
}
```

解决方法

- 闭包：

```js
for (var i = 1; i <= 5; i++) {
  (function(j) {
      setTimeout(function timer() {
        console.log(j)
      }, j * 1000)
  })(i)
}
```

- 利用 setTimeout 的第三个参数，这个参数会被当成回调的参数传入

```js
for (var i = 1; i <= 5; i++) {
  setTimeout(function timer(j) {
    console.log(j)
  }, i * 1000, i)
}
```

- let

```js
for (let i = 1; i <= 5; i++) {
  setTimeout(function timer() {
    console.log(i)
  }, i * 1000)
}
```

8. 什么是浅拷贝和深拷贝？分别如何实现？

浅拷贝只会拷贝对象的第一层

`Object.assign()` 和 `{ ... }` 可实现浅拷贝

通常用 `JSON.parse(JSON.stringify())` 实现深拷贝，但是它会忽略 `undefined` 和 `symbol`值的属性，并且不能序列化函数，不能解决循环引用的对象

推荐使用 `loadsh` 的深拷贝函数

9. 如何理解原型和原型链？

每个 JS 对象都有 `__proto__` 属性，这个属性指向原型。

原型也是一个对象，其中的 `constructor` 属性指向构造函数，构造函数又通过 `prototype` 属性指向原型，但是并不是所有函数都具有这个属性， `Function.prototype.bind()` 就没有这个属性

原型链就是多个对象通过 `__proto__` 的方式连接了起来

10. 什么是提升？什么是暂时性死区？ var、let 及 const 的区别？

函数提升优先于变量提升，函数提升会把整个代码块挪到作用域顶部，变量提升只会把声明挪到作用域顶部。

`let` 和 `const` 声明的变量不会挂载到 `window` 上，由于存在暂时性死区，不能在声明前就使用变量。`const` 必须在声明时赋值，且不能再次赋值

提升存在的根本原因是为了解决函数间相互调用的情况

```js
function test1() {
    test2()
}
function test2() {
    test1()
}
test1()
```

11. 原型如何实现继承？Class 如何实现继承？Class 本质是什么？

