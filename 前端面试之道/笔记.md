1. 原始类型有哪几种？null 是对象吗？

原始类型存储的都是值，没有函数可以调用。包括：`undefined`、`string`、`number`、`boolean`、`symbol`、`null`

`typeof null` 等于 `object`。为了性能考虑使用低位存储变量的类型信息，`000` 开头代表是对象，然后 `null` 全为零。

2. 对象类型和原始类型的不同之处？函数参数是对象会发生什么问题？

原始类型存储的是值，对象类型存储的是地址（指针）。

当将变量赋值给另外一个变量时，复制的是原本变量的地址。

3. typeof 是否能正确判断类型？instanceof 的原理？

对于原始值来说，除了 `null` 都可以显示正确的类型

instanceof 内部是通过原型链(__proto__)来判断的

`Symbol.hasInstance` 是一个能让我们自定义 `instanceof` 的东西

```js
class PrimitiveString {
  static [Symbol.hasInstance](x) {
    return typeof x === 'string'
  }
}
console.log('hello world' instanceof PrimitiveString) // true
```

4. 类型转换（笔试题）

类型转换只有三种情况，分别是：

- 转换为布尔值

- 转换为数字

- 转换为字符串

转 `Boolean`：除了 `undefined`、`null`、 `0`、`false`、`NaN`、`''`，其他都转为 `true`

转原始类型：

- 已经是原始类型，无需转换

- 需要转字符串就调用 `toString()`，转换为基础类型就返回转换的值。不是字符串类型就先调用 `valueOf()`，再调用 `toString()`

- 调用 `valueOf()`，如果转换为基础类型，就返回

- 都没有返回原始类型，报错

可以重写 `Symbol.toPrimitive`，该方法在转原始类型时调用优先级最高

```js
let a = {
  valueOf() {
    return 0
  },
  toString() {
    return '1'
  },
  [Symbol.toPrimitive]() {
    return 2
  }
}
1 + a // => 3
```

加法运算符两方如果其中一方为字符串，会把另一方也转换成字符串。如果一方不是字符串或数字，那么会将它转换为数字或者字符串

```js
1 + '1' // '11'
true + true // 2
4 + [1,2,3] // "41,2,3"
'a' + + 'b' // "aNaN" 先执行 + 'b'
```

除了加法的运算符，只要其中一方是数字，那么另一方会被转为数字

比较运算符中，如果是对象，就通过 `toPrimitive` 转换对象。如果是字符串，通过 `unicode` 比较

```js
let a = {
  valueOf() {
    return 0
  },
  toString() {
    return '1'
  }
}
a > -1 // true 调用 valueOf
```

5. 如何正确判断 this？箭头函数的 this 是什么？

`new` 构造函数方式：`this` 固化在实例上

普通函数调用：谁调用函数，`this` 就指向谁

箭头函数的 `this` 只取决于包裹箭头函数的第一个普通函数的 `this`。对箭头函数使用 `bind` 这类函数是无效的

函数调用多次 `bind` 后最终返回的函数的 `this` 永远由第一次 `bind` 决定

```js
// fn.bind().bind(a) 等于
let fn2 = function fn1() {
  return function() {
    return fn.apply()
  }.apply(a)
}
fn2()
```

6. == 和 === 的区别？

`==` 在对方类型不一致的情况下回进行类型转换

- 判断类型是否相同，相同则比较大小

- 类型不同，进行类型转换

- 判断是否在比较 `null` 和 `undefined`，是则返回 `true`

- 判断两者类型是否为 `string` 和 `number`，是的话就将字符串转换为 `number`

- 判断其中一方是否为 `boolean`，是的话就把 `boolean` 转为 `number` 再进行判断

- 判断其中一方是否为 `object`，且另一方为 `string`、`number` 或者 `symbol`，是的话将 `object` 转为原始类型

`===` 判断两者类型和值是否相同

7. 什么是闭包？

函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包。

```js
function A() {
  let a = 1
  window.B = function () {
      console.log(a)
  }
}
A()
B() // 1
```

闭包存在的意义就是让我们可以间接访问函数内部的变量

8. 闭包面试题：第1秒输出1，第2秒输出2，...

```js
for (var i = 1; i <= 5; i++) {
  setTimeout(function timer() {
    console.log(i)
  }, i * 1000)
}
```

解决方法

- 闭包：

```js
for (var i = 1; i <= 5; i++) {
  (function(j) {
      setTimeout(function timer() {
        console.log(j)
      }, j * 1000)
  })(i)
}
```

- 利用 setTimeout 的第三个参数，这个参数会被当成回调的参数传入

```js
for (var i = 1; i <= 5; i++) {
  setTimeout(function timer(j) {
    console.log(j)
  }, i * 1000, i)
}
```

- let

```js
for (let i = 1; i <= 5; i++) {
  setTimeout(function timer() {
    console.log(i)
  }, i * 1000)
}
```

8. 什么是浅拷贝和深拷贝？分别如何实现？

浅拷贝只会拷贝对象的第一层

`Object.assign()` 和 `{ ... }` 可实现浅拷贝

通常用 `JSON.parse(JSON.stringify())` 实现深拷贝，但是它会忽略 `undefined` 和 `symbol`值的属性，并且不能序列化函数，不能解决循环引用的对象

推荐使用 `loadsh` 的深拷贝函数

9. 如何理解原型和原型链？

每个 JS 对象都有 `__proto__` 属性，这个属性指向原型。

原型也是一个对象，其中的 `constructor` 属性指向构造函数，构造函数又通过 `prototype` 属性指向原型，但是并不是所有函数都具有这个属性， `Function.prototype.bind()` 就没有这个属性

原型链就是多个对象通过 `__proto__` 的方式连接了起来

10. 什么是提升？什么是暂时性死区？ var、let 及 const 的区别？

函数提升优先于变量提升，函数提升会把整个代码块挪到作用域顶部，变量提升只会把声明挪到作用域顶部。

`let` 和 `const` 声明的变量不会挂载到 `window` 上，由于存在暂时性死区，不能在声明前就使用变量。`const` 必须在声明时赋值，且不能再次赋值

提升存在的根本原因是为了解决函数间相互调用的情况

```js
function test1() {
    test2()
}
function test2() {
    test1()
}
test1()
```

11. 原型如何实现继承？Class 如何实现继承？Class 本质是什么？

`class` 只是语法糖，本质还是函数。

- 组合继承（`Parent.call()` + `new Parent()`）

缺点：调用了父类构造函数，子类的原型上多了父类的属性，存在内存上的浪费

```js
// 组合继承
function Parent(name) {
    this.name = name
}
Parent.prototype.say = function() {
    console.log(this.name);
}

function Child(name) {
    Parent.call(this, name)
}
// new Parent() =>  实例的 __proto__  指向 Parent.prototype
Child.prototype = new Parent()

// new Child => __proto__ 指向 Child.prototype => __proto__ 指向 Parent的实例 => 实例的 __proto__ 指向 Parent.prototype
const child = new Child('child')
console.dir(Child)
console.dir(child)
child.say()
```

- 寄生组合继承

优化上面一种方法

```js
// 寄生组合继承
function Parent(name) {
    this.name = name
}
Parent.prototype.say = function() {
    console.log(this.name);
}

function Child(name) {
    Parent.call(this, name)
}

Child.prototype = Object.create(Parent.prototype, {
    constructor: {
        value: Child,
        enumerable: false,
        writable: true,
        configurable: true
    }
})

const child = new Child('child')
console.dir(Child)
console.dir(child)
child.say()
```

- class 继承

```js
// class 继承
class Parent {
    constructor(name) {
        this.name = name
    }
    say() {
        console.log(this.name);
    }
}

class Child extends Parent {
    constructor(name) {
        super(name)
    }
}

const child = new Child('class 继承')
child.say()
```

12. 为什么要使用模块化？有哪几种方式可以实现模块化，各有什么特点？

模块化的好处：

- 解决命名冲突

- 提高复用性

- 提高代码可维护性

实现模块化：

- 立即执行函数

- AMD 和 CMD

```js
// AMD
define(['./a', './b'], function(a, b) {
  // 加载模块完毕可以使用
  a.do()
  b.do()
})
// CMD
define(function(require, exports, module) {
  // 加载模块
  // 可以把 require 写在函数体的任意地方实现延迟加载
  var a = require('./a')
  a.doSomething()
})
```

- CommonJS

```js
// a.js
module.exports = {
    a: 1
}
// or 
exports.a = 1

// b.js
var module = require('./a.js')
module.a // -> log 1
```

```js
var module = require('./a.js')
module.a 
// 这里其实就是包装了一层立即执行函数，这样就不会污染全局变量了，
// 重要的是 module 这里，module 是 Node 独有的一个变量
module.exports = {
    a: 1
}
// module 基本实现
var module = {
  id: 'xxxx', // 我总得知道怎么去找到他吧
  exports: {} // exports 就是个空对象
}
// 这个是为什么 exports 和 module.exports 用法相似的原因
var exports = module.exports 
var load = function (module) {
    // 导出的东西
    var a = 1
    module.exports = a
    return module.exports
};
// 然后当我 require 的时候去找到独特的
// id，然后将要使用的东西用立即执行函数包装下，over
```

- ES Module

与 `CommonJS` 的区别：

1. CommonJS 支持动态导入，也就是 `require(${path}/xx.js)`，后者不支持，但已有提案

2. CommonJS 是同步导入，用于服务端，同步导入会卡主主线程但影响不大。后者是异步导入，用于浏览器时需要下载文件。

3. CommonJS 在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，想要更新值，必须重新导入一次。后者采用实时绑定的方式，导入导出的值都指向同一个内存，导入值会跟随导出值变化。

```js
// 引入模块 API
import XXX from './a.js'
import { XXX } from './a.js'
// 导出模块 API
export function a() {}
export default function() {}
```

13. Proxy 可以实现什么功能？

Vue3.0 中通过 `Proxy` 来替换原本的 `Object.defineProperty` 来实现数据响应式。原因是 `Proxy` 无须一层层递归为每个属性添加代理，一次即可完成以上操作，性能更优，并且可以完美监听到任何方式的数据改变。

`Proxy` 是 ES6 中新增的功能，可以用来自定义对象中的操作。

```js
const onWatch = (obj, setbind, getLogger) => {
    const handler = {
        get(target, property, receiver) {
            getLogger(target[property], property)
        },
        set(target, property, value, receiver) {
            setbind(value, property)
            return Reflect.set(target, property, value)
        }
    }
    return new Proxy(obj, handler)
}

const obj = {
    a: 1
}
const p = onWatch(obj, (v, property) => {
    console.log(`属性${property}改变为${v}`);
}, (target, property) => {
    console.log(`获取属性${property}值，为${target}`);
})

console.log(p);
p.a
p.a = 2
p.a
```

14. map, filter, reduce 各自的作用？

`map` 是遍历数组，生成一个新数组。参数分别为当前元素、索引、原数组

```js
['1','2','3'].map(parseInt) // [1, NaN, NaN]
```

`filter` 遍历数组，将返回值为 `true` 的元素放入新数组。

`reduce` 可以将数组中的元素通过回调最终转换为一个值。参数为回调函数和初始值。回调函数的参数为上一次结果(第一次为初始值)、当前元素、索引、原数组。

```js
const arr = [1, 2, 3]
const sum = arr.reduce((acc, current) => acc + current, 0)
console.log(sum) // 6
```

```js
// reduce 实现 map
const arr = [1, 2, 3]
const mapArray = arr.map(value => value * 2)
const reduceArray = arr.reduce((acc, current) => {
  acc.push(current * 2)
  return acc
}, [])
console.log(mapArray, reduceArray) // [2, 4, 6]
```

15. 并发与并行的区别？

并发是宏观概念，有任务 A 和任务 B，在一段时间内通过任务间的切换完成了这两个任务，这种情况可以称之为并发。

并行是微观概念，加入 CPU 中存在两个核心，那么可以同时完成任务 A 和 B。同时完成多个任务的情况就可以称之并行。

16. 什么是回调函数？回调函数的缺点？如何解决回调地狱问题？

不利于阅读和维护。

回调地狱的根本问题：

- 嵌套函数存在耦合性

- 嵌套函数一多，很难处理错误

- 不能使用 `try catch` 捕获错误，不能直接 `return`

解决方法在后面会提到。

17， 你理解的 Generator 是什么？

`Generator` 最大的特点是可以控制函数的执行。和普通函数不同，它会返回一个迭代器。可以用来解决回调地狱的问题。

执行第一次 `next` 时，传参会被忽略，函数暂停在第一个 `yield`。后面执行 `next` 时，传入的参数会被当做上一个 `yield` 的返回值，如果不传参，会返回 `undefined`

```js
function *foo(x) {
    let y = 2 * (yield (x + 1))
    let z = yield (y / 3)
    return (x + y + z)
}
let it = foo(5)
console.log(it.next()); // {value: 6, done: false}
console.log(it.next(12)); // {value: 8, done: false}
console.log(it.next(13)); // {value: 42, done: true}
// x = 5 y = 24 z = 13
```

```js
function *fetch() {
    yield ajax(url, () => {})
    yield ajax(url1, () => {})
    yield ajax(url2, () => {})
}
let it = fetch()
let result1 = it.next()
let result2 = it.next()
let result3 = it.next()
```

18. Promise 的特点是什么，分别有什么优缺点？什么是 Promise 链？Promise 构造函数执行和 then 函数执行有什么区别？

`Promise` 有三种状态：`pending`(等待中)、`resolved`(已完成)、`rejected`(已拒绝)，一旦从等待状态变成其他状态就不能更改状态了。

构造函数内部的代码是立即执行的。

`Promise` 实现了链式调用，也就是说每次调用 `then` 之后返回的都是一个 `Promise`，并且是一个新的 `Promise` 实例。如果在 `then` 中使用了 `return`，那么 `return` 的值会被 `Promise.resolve()` 包装。

`Promise` 解决了回调地狱的问题。

`Promise` 的缺点：无法取消，错误需要通过 `catch` 捕获（外部 try catch 捕获不到）

19. async 及 await 的特点及优缺点，await 原理是什么

一个函数加上 `async`，那么该函数就会返回一个 `Promise`。

`async` 就是将函数返回值使用 `Promise.resolve()` 包裹了下，和 `then` 中处理返回值一样。

`await` 只能和 `async` 一起使用。它们可以说是异步的终极解决方案。

`await` 内部实现了 `generator`，其实 `await` 就是 `generator` 加上 `Promise` 的语法糖，且内部实现了自动执行 `generator`。

相对于 `Promise`，处理了 `then` 的调用链。由于把异步代码改造成了同步代码，如果多个异步代码没有依赖性却使用了 `await` 会导致性能上的降低。

```js
let a = 0
let b = async () => {
  a = a + await 10
  console.log('2', a) // -> '2' 10
}
b()
a++
console.log('1', a) // -> '1' 1
/*
首先函数 b 先执行，在执行到 await 10 之前变量 a 还是 0，因为 await 内部实现了 generator ，generator 会保留堆栈中东西，所以这时候 a = 0 被保存了下来
因为 await 是异步操作，后来的表达式不返回 Promise 的话，就会包装成 Promise.reslove(返回值)，然后会去执行函数外的同步代码
同步代码执行完毕后开始执行异步代码，将保存下来的值拿出来使用，这时候 a = 0 + 10
*/
```

19. setTimeout、setInterval、requestAnimationFrame 各有什么特点？

`setTimeout` 不是延时多久，就会多久后执行。JS 是单线程执行的，如果前面的代码影响了性能，就会导致 `setTimeout` 不会按期执行。

`setInterval` 也不能保证在延期的时间执行任务，并且存在执行累积的问题。如果执行过程中出现了耗时操作，多个回调函数会在耗时操作结束之后同时执行。

`requestAnimationFrame` 自带函数节流功能，基本可以保证在16.6毫秒内执行一次（不掉帧的情况），并且未活动的标签页会暂停以节约性能。可以替代以上两种方法。
