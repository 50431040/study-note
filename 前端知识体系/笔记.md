# 笔记

## JavaScript

### 基础知识

#### 声明提升

- 变量提升：
  
var定义的变量会声明提升到它所在作用域的顶端，允许“先使用后声明”。

奇怪的现象：

```js
console.log(name); // jlq
var name = 'jlq'
```

- 函数提升：

函数定义：1. 函数声明式 2. 函数字面量式。

函数提升是将 *** 整个代码块 *** 提升到作用域顶端。

在函数内部的var变量仍然会进行变量提升。

#### let & const

- let，const定义的变量如果在声明前就使用会抛出异常。

- 在函数参数中依然遵循“先声明后使用”原则。

#### let & const & var 异同点

- 相同点：

1. 都遵循“先声明后使用”原则，函数内部优先查找内部是否声明，未声明可访问外部变量。

- 不同点

1. var 和 let 可以单独声明，后面再赋值。const 在声明时必须同时赋值，且值不允许再次改变。

2. var 不存在块作用域的概念，let 和 const 存在。

3. var 声明的变量可重复声明，let 和 const 不可。

- 注意

const 不可改变的是其内存地址值，对于引用类型的值而言，可以改变其内部成员。

#### 全局污染 & 块作用域

避免全局污染：

1. IIFE

2. 全局变量命名空间

3. 块作用域

#### 对象冻结

Object.freeze()

1. 不能添加，修改，删除属性

2. 不能修改对象的可枚举性，可配置性，可写性

3. 返回和传入参数相同的对象

4. 传入数组也是如此

### 数据类型

#### typeof & instanceof

- typeof只适用于判断基础类型

- instance用于判断引用类型

- instanceof原理：左边的变量沿着原型链一直往上找，是否存在和右边变量prototype相等的

#### 字符串

- 常用函数

1. trim

2. trimStart

3. trimEnd

4. toUpperCase

5. toLowerCase

- 截取

1. slice

2. substring（参数若为负数都当做0处理）

3. substr（第二个参数为截取个数）

slice适用于正反向截取，substring适用于正向截取，substr适用于正反向截取指定个数的字符串。

- 查找

1. indexOf

2. lastIndexOf (在一个字符串中的指定位置从后向前搜索。)

3. startsWith

4. endsWith

5. includes

6. charAt

7. charCodeAt

- 替换

1. replace

- 类型转换

1. 字符串转数字

转换前确定当前字符串一定为数字，可以用 * 1 或 +num 或 Number()，不确定则使用parseInt() 或 parseFloat()

2. 数字转字符串

加空字符串 | String() | toString()

3. 字符串转数组

split()

4. 数组转字符串

join() | toStirng()

5. 字符串字面量

```js
const str3 = new String('456')
console.log(typeof str3); // object
```

- 其他操作

1. repeat

复制指定次数

#### 布尔值

- 隐式转换为false的情况

0 | '' | null | undefined

- 显式转换

Boolean | !!

#### 数值

- 基本使用

1. Number.isInteger()

判断是否为整数

2. toFixed()

保留几位小数点

- 类型转换

1. 判断一个值是不是非数值

Number.isNaN | Object.is(num, NaN)

2. 任何值和NaN都不相等，包括它自身

3. 布尔值

true => 1

false => 0

1. 字符串

```js
const s = '123abc'
console.log(Number(s)); // NaN
console.log(parseInt(s)); // 123
```

5. 数组

空数组 => 0

单值数组 => Number(该单值)（必须为数值或字符串）

多值 => NaN

6. 对象

空对象和普通对象 => NaN

实现了valueOf的对象 => Number(valueOf返回值)

- 数学运算

1. Math.min() | Math.max()

2. Math.floor() | Math.ceil() | Math.round()

3. Math.random()

#### 日期

- 基础

1. Date()

返回的为日期字符串

2. new Date()

返回的是日期对象

```js
console.log(new Date());
console.log(new Date('2020-01-03 15:40:10'));
console.log(new Date(2020, 3, 5, 10, 30, 12));
console.log(new Date(1592043188332));
```

3. Date.now()

当前日期毫秒数

- 类型转换

1. 时间戳 => 日期

new Date(timestamp)

2. 日期 => 时间戳

getTime() | +new Date() | valueOf() | Number()

- 日期格式化

1. getFullYear()

2. getMonth()

3. getDate()

4. getDay()

5. getHours()

6. getMinutes()

7. getSeconds()

```js
function formatDate(date, format="YYYY-MM-DD HH:mm:ss") {
    const d = typeof date === 'object' ? date : new Date(date)
    const obj = {
        YYYY: d.getFullYear(),
        MM: d.getMonth(),
        DD: d.getDate(),
        HH: d.getHours(),
        mm: d.getMinutes(),
        ss: d.getSeconds()
    }
    for(let key in obj) {
        if (String(obj[key]).length === 1) { // 得到是数值类型，需要转为字符串
            obj[key] = '0' + obj[key]
        }
        format = format.replace(key, obj[key])
    }
    return format
}
```



### 运算符与流程控制

#### 算数运算符

- 加减乘除余：+ | - | * | / | %

- 大整数越界

```js
console.log(9999999999999999 == 10000000000000001) // true
console.log(9007199254740992 + 1 == 9007199254740992) // true
console.log(Number.MAX_VALUE); // 1.7976931348623157e+308
console.log(Number.MIN_VALUE); // 5e-324
console.log(Number.MAX_SAFE_INTEGER); // 9007199254740991
console.log(Number.MIN_SAFE_INTEGER); // -9007199254740991
```

- 精度丢失

计算机编程语言里浮点数计算会存在精度丢失问题（或称舍入误差），其根本原因是二进制和实现位数限制有些数无法有限表示。

以下是十进制小数对应的二进制表示:

0.1 >> 0.0001 1001 1001 1001…（1001无限循环）

0.2 >> 0.0011 0011 0011 0011…（0011无限循环）

计算机里每种数据类型的存储是一个有限宽度，比如 JavaScript 使用 64 位存储数字类型，因此超出的会舍去。舍去的部分就是精度丢失的部分。

```js
console.log(0.1 + 0.2 === 0.3); // false
console.log(0.1 + 0.2); // 0.30000000000000004
console.log(1.335.toFixed(2)); // 1.33
```

- 解决精度丢失

```js
function SafeFloat() {
    // 转为整数 返回 处理后的整数和倍数
    this.toInteger = function(num) {
        const obj = {
            num,
            times: 1
        }
        if (Number.isInteger(num)) {
            return obj
        }
        const str = num + ''
        const dotPos = str.indexOf('.')
        const len = str.slice(dotPos + 1).length
        obj.times = Math.pow(10, len)
        obj.num = num * Math.pow(10, len)
        return obj
    }

    this.operation = function(a, b, op) {
        const o1 = this.toInteger(a)
        const o2 = this.toInteger(b)
        const num1 = o1.num
        const num2 = o2.num
        const t1 = o1.times
        const t2 = o2.times
        const max = Math.max(t1, t2)
        let result
        switch(op) {
            case 'add':
                if (t1 === t2) {
                    result = num1 + num2
                } else if (t1 > t2) {
                    result = num1 + num2 * (t1 / t2)
                } else {
                    result = num2 + num1 * (t2 / t1)
                }
                return result / max
                break
            case 'sub':
                if (t1 === t2) {
                    result = num1 + num2
                } else if (t1 > t2) {
                    result = num1 - num2 * (t1 / t2)
                } else {
                    result = num1 * (t2 / t1) - num2
                }
                return result / max
                break
            case 'mul':
                result = (num1 * num2) / (t1 * t2)
                return result
                break
            case 'div':
                result = (num1 / num2) * (t1 / t2)
                return result / max
                break
        }
    }
}
SafeFloat.prototype.add = function(a, b) {
    return this.operation(a, b, 'add')
}
SafeFloat.prototype.sub = function(a, b) {
    return this.operation(a, b, 'sub')
}
SafeFloat.prototype.mul = function(a, b) {
    return this.operation(a, b, 'mul')
}
SafeFloat.prototype.div = function(a, b) {
    return this.operation(a, b, 'div')
}

const sf = new SafeFloat()
console.log(sf.add(0.1, 0.2) === 0.3);
console.log(sf.mul(0.1, 0.2) === 0.02);
```

### 数组

#### 创建

- []

- new Array()

传入多个参数时将正常构建数组，只有一个参数时，将创建指定长度数据项为empty的数组

- Array.of()

根据传入的参数构建数组，不区分个数

- 跨索引赋值时，中间的数据项会自动填充empty

- empty 为空单元，不等于 undefined

- 创建指定长度数据项为undefined的数组

```js
Array.apply(null, { length: 3 }) // [undefined, undefined, undefined]
```

#### 类型转换

- 检测是否数组

1. Array.isArray()

2. instanceof

- 数组转字符串

1. String()

2. toString()

3. join()

- 字符串转数组

1. split()

2. Array.from()

Array.from()可转换具备length属性的元素，常用于DOM元素集合的转换, 第二个参数可依次操作每个元素

#### 展开运算符

- 合并多个数组

- 函数声明可变参数

```js
const sum = (...args) => {
    return args.reduce((pre, cur) => pre += cur, 0)
}
```

- DOM元素集合转为数组

```js
const lis = document.querySelectorAll('li');

// 上面一句必须加上分号
[...lis].map(li => {
    li.addEventListener('click', function() {
        this.style.background = 'red'
    })
})
```

#### 解构赋值

- 可将数组中的元素依次赋值给左边声明的变量

- 可将字符串进行解构赋值，即转化为字符数组

- 当左侧声明的变量小于右侧数组的长度，则最后一个变量接收所有剩余的成员(仍然是数组)

- 当左侧声明的变量大于右侧数组的长度，则左侧变量不够分配时后续变量为undefined,但可设置默认值

- ...语法在表达式左侧则解构，放在表达式右侧则展开

- 解构也可应用于函数参数声明

```js
function getMsg([name, age, address]) {
    console.log(name, age, address);
}
getMsg(['Jack', 12, 'ChengDu']) // Jack 12 ChengDu
```

#### 追加元素

- 展开运算符

- push

返回值是操作后数组的长度

#### 出入栈及填充

- push()、unshift()

返回值为操作后数组的长度

- pop()、shift()

返回值为弹出的元素具体值

- fill

```js
const arr = Array(3).fill(undefined)
console.log(arr); // [undefined, undefined, undefined]

const arr2 = Array(5).fill(undefined, 1, 3)
// empty不计入
console.log(arr2, arr2[0], arr2[1], arr[2]); // undefined undefined

const arr3 = [1, 2, 3, 4, 5].fill(0, 1, 3)
console.log(arr3, arr3[0], arr3[1]); // 1 0
```

#### 增删改查

- slice

- push | pop | unshift | shift

- splice

返回截取项组成的数组

#### 清空

- 赋值为[]

- length = 0

- splice(0)

- 循环pop/shift

#### 连接及复制

- concat

- copyWithin(target, start, end)

target: 指定目标索引位置

start: 复制的起始位置

end: 停止复制的索引位置（不包含）

#### 查找元素

- indexOf / lastIndexOf

找到返回索引值，否则返回 -1

- find

找到返回匹配的值，否则返回 undefined

- findIndex

找到返回索引值，否则返回 -1

- includes

找到返回 true，否则返回 false

#### 排序

- sort

```js
// 自定义sort
function sort(arr, fn) {
    for(let i in arr) {
        for(let j in arr) {
            if (fn(arr[i], arr[j]) < 0) {
                let temp = arr[i]
                arr[i] = arr[j]
                arr[j] = temp
            }
        }
    }
}
```

#### 遍历

- 遍历方法

1. for

2. for in

3. for of

4. forEach

- dom元素集合可使用forEach直接遍历

- break无法跳出forEach循环，可使用try catch

```js
const arr = [1, 2, 3, -1, 5]
try {
    arr.forEach(item => {
        if (item < 0) throw new Error('')
        console.log(item);
    })
} catch (err) {}
```

- continue无法跳出forEach的本次循环，可使用return false

```js
arr.forEach(item => {
    if (item < 0) return false
    console.log(item);
})
```

#### 迭代器

- keys()

- values()

- entries()

```js
const arr = [12, 14, 123, 15]
const keyIterator = arr.keys()
const valueIterator = arr.values()

for(let key of keyIterator) {
    console.log(key);
}
for(value of valueIterator) {
    console.log(value);
}

const iterator = arr.entries()
for([key, value] of iterator) {
    console.log(key, value);
}

const iterator2 = arr.entries()
while(({done, value} = iterator2.next()) && !done) {
    const [key, val] = value
    console.log(key, val, done);
}
```

#### 逻辑

- every

每一项都满足

- some

某一项满足

#### 过滤

- filter

不会改变原数组，返回一个新的数组

#### 映射

- map

返回一个新数组，如果原数组某项为引用类型，在此基础上修改了则会影响原数组

#### 累积

- reduce / reduceRight

### 函数

#### 基础

- new Function()

- function() {}

- var = function() {}

#### 匿名函数

- var = function() {}

- 函数表达式与匿名函数定义方式的区别：前者存在函数提升

#### 立即执行函数

- (function() {})()

- 解决了命名冲突问题