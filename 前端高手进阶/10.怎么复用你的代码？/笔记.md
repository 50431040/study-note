# 模块化

## ES6 模块

1. ES6 模块强制自动采用严格模式。

2. 需要在 script 标签中将属性 type 值设置为 `module` 才能正确地被解析为 ES6 模块。

3. 在 Node.js 下使用 ES6 模块需要将文件名后缀改为 `.mjs`。

### 特性

- 值引用

**export** 语句输出的接口，与其对应的值是动态绑定关系。即通过该接口，可以取到模块内部实时的值，可以简单地理解为浅拷贝。

- 静态声明

不需要执行代码，只从字面量上对代码进行分析。方便优化代码体积，可以通过 `tree-shaking` 操作消除模块中没有被引入或者执行结果不会被用到的无用代码。

## CommonJS

### 定义和引用

规定每个文件就是一个模块，有独立的作用域。每个模块内部，都有一个 `module` 对象，通过它来导出 API，它有以下属性：

- id 模块识别符

- filename 模块文件名

- loaded 返回一个布尔值，表示是否已经完成加载

- parent 返回一个对象，表示调用该模块的模块

- children 返回一个数组，表示该模块要用到的其他模块

- exports 表示模块对外输出的值

引用模块则需要通过 `require` 函数，读入并并执行一个 `JavaScript` 文件，然后返回该模块的 `exports` 对象。

### 特性

- 值拷贝

和值引用相反，一旦输出一个值，模块内部的变化就影响不到这个值了，可以简单地理解为变量深拷贝。

- 动态声明

可以自由地在表达式语句中引用模块。

## AMD

### 定义和引用

只定义了一个全局函数 `define`，通过它就可以定义和引用模块。

```js
define(id?, dependencies?, factory)
```

id => 模块名称，默认为加载器请求的指定脚本的名字。dependencies => 数组，定义所依赖的模块。依赖模块必须根据模块的工厂函数优先级执行，并且执行的结果应该按照依赖数组中的位置顺序以参数的形式传入工厂函数中。factory => 模块初始化要执行的函数或对象。如果为函数，那么该函数只会执行一次。如果是对象，此对象为模块的输出值。

### 特性

异步加载，指的是同时并发加载所依赖的模块，当所有依赖模块都加载完成后，再执行当前模块的回调函数。这种加载方式和浏览器环境的性能需求刚好吻合。由于 AMD 并不是浏览器原生支持的模块规范，所以需要借助第三方库实现，其中最有名的就是 `RequireJS`。

## CMD

### 定义和引用

同样通过一个全局函数 `define` 实现，但只有一个参数，该参数既可以是函数也可以是对象。

```js
define(factory)

define(function(require, exports, module) {})
```

如果参数是对象，那么模块导出的就是对象。如果参数是函数，那么这个函数会被传入三个参数：require、exports 和 module。

require => 函数，用来引用其他模块，也可以调用 `require.async` 函数来异步调用模块。exports => 对象，当定义模块时，通过向其添加属性来导出模块。module => 对象，包括三个属性：uri，模块完整的 URI 路径。dependencies，模块的依赖。exports，需要被导出的 API，作用同 `exports`。

### 特性

懒加载。不需要在定义模块时就声明依赖，可以在执行时动态加载模块。但是 CMD 同时支持同步和异步加载模块。

## UMD

通过 UMD 可以在合适的环境选择对应的模块规范。比如在 Node.js 换将中采用 CommonJS 模块，在浏览器端且支持 AMD 的情况下采用 AMD 模块，否则导出为全局函数。

实现原理：

- 判断 `exports` 是否存在，存在则使用 Node.js 模块格式。

- 判断 `define` 是否存在，存在则使用 AMD 方式。

- 若两个都不存在，则将模块公开到全局（Window 或 Global）。