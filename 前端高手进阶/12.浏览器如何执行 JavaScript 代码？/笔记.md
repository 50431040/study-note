# JavaScript 引擎

## 编译

- 解析

1. 词法分析

将 JavaScript 代码解析成一个个的令牌（Token）

2. 语法分析

将令牌组装成一棵抽象语法树（AST）

- 解释

通过解释器 Ignition 将 AST 转换成字节码。字节码是对机器码的一个抽象描述，相对于机器码而言，它的代码量更小，从而减少内存消耗。

- 优化

解释器得到 AST 后，会按需进行解释和执行。如果某个函数没有被调用，不会去解释执行它。在这个过程中，解释器会将一些重复可优化的操作收集起来生成分析数据，将生成的字节码和分析数据传给编译器 TurboFan，编译器会依据分析数据来生成高度优化的机器码。优化后的机器码的作用和缓存类似，当解释器再次遇到相同的内容就可以直接执行优化后的机器码。优化后的代码有可能无法运行（函数参数类型改变），那么会再次反优化为字节码交给解释器。

## 内存管理

分为堆和栈，堆是具有树结构的数组，栈也是数组，遵循“先进后出”。

### 栈

- 临时存储空间，主要存储局部变量和函数调用。对于基本类型的局部变量会直接在栈中创建，对象数据类型的局部变量会存储在堆中，栈只存储它的引用地址。全局变量以及闭包变量也是只存储引用地址。

- 对于函数，解释器创建了“调用栈”来记录函数的调用流程。每调用一个函数，解释器就会把该函数添加进调用栈，解释器会为被添加进的函数创建一个栈帧（Stack Frame，这个栈帧用来保存函数的局部变量以及执行语句）。如果正在执行的函数还调用了其他函数，那么新函数也将会被添加进调用栈并执行。一旦函数执行结束，对应的栈帧也会被立即摧毁。

- 查看调用栈：console.trace()、断点调试。

- 递归调用由于调用次数较多，同时每层函数调用都需要保存栈帧，所以比较消耗内存，对递归的优化一般有两个思路：减少递归次数和使用尾调用。

### 堆

堆空间大致分为五个区域：代码区、Map 区、大对象区、新生代、老生代。

- 新生代：大多数对象最开始都会分配在新生代，该存储空间相对较小，只有几十 MB，分为 from 空间和 to 空间。声明的对象首先会被分配到 from 空间，当进行垃圾回收时，会先将 from 空间存活的对象复制到 to 空间，对未存活的对象空间进行回收。复制完成后，from 空间和 to 空间进行调换。这种算法称之为 Scanvage。新生代的内存回收频率高，速度快，但控件利用率较低，因为一半的内存空间处于“闲置”状态。

- 老生代：新生代中多次回收仍然存活的对象会被转移到空间较大的老生代。老生代采用的是“标记清除”来回收未存活的对象空间。标记阶段会遍历堆中所有对象，并对存活的对象进行标记，清除阶段则对未标记对象的空间进行回收，在这之后会产生很多不连续的碎片控件。为了解决内存碎片的问题，提高内存的利用，需要使用标记整理算法，在回收阶段进行了改进，对于未标记的对象并不是立即回收，而是将存活的对象移到一边，然后再清理。但是这种移动操作比较耗时。

