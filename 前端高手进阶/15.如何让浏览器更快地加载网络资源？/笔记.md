# 缓存

## 强制缓存

在浏览器加载资源时，先从缓存中查找，不存在再向服务端发起请求。

### Expires

- 设置缓存过期时间，是一个时间戳。

- 服务端和浏览器端的时间可能不一致，容易出现偏差。客户端可以通过修改系统时间来继续使用缓存或提前让缓存失效。

### Cache-Control

- 常用值：
1. no-cache 使用协商缓存，即每次使用缓存前必须向服务端确认缓存资源是否更新
2. no-store 禁止浏览器及所有中间缓存存储响应内容
3. public 公有缓存，表示可以被代理服务器缓存，可以被多个用户共享
4. private 私有缓存，不能被代理服务器缓存，不可用被多个用户共享
5. max-age 以秒为单位的数值，表示缓存的有效时间
6. must-revalidate 当缓存过期时，需要去服务端校验缓存的有效性

- 以上的值可以组合使用

- Cache-Control 的 `max-age` 优先级高于 Expires

## 协商缓存

发送请求到服务端进行确认缓存是否更新，返回 304 则表示缓存有效。

### Last-Modified 和 If-Modifiend-Since

- 工作流程：
1. 浏览器第一次请求资源，服务端在返回资源的响应头加上 `Last-Modified `字段，表示这个资源在服务端上的最近修改时间。
2. 当再次请求资源时，请求头部 `If-Modified-Since` 带上服务端返回的修改时间。
3. 服务端根据请求头判断资源是否变化，无变化返回 304 Not Modified，否则返回资源内容，且更新 Last-Modified 响应头。

- 问题：
1. 精度问题。时间精度为秒，在 1s 内发生修改，缓存判断会失效。
2. 准度问题。如果一个文件被修改，又被还原，内容没有发生变化，由于修改时间变化，缓存会失效。

### ETag 和 If-None-Match

- 不依赖于时间，依赖于文件哈希值。

- 具体流程：
1. 第一次请求资源，服务端在响应头中加入 ETag 字段
2. 再次请求时，在请求头中加上 `If-None-Match` 字段
3. 对比

- 问题：
1. 计算成本。生成哈希值相对于读取文件修改时间而言是一个开销较大的操作。尤其是对于大文件而言。如果要精确计算需要读取完整的文件内容，只读取部分内容又容易判断出错。
2. 计算误差。不同服务端可能采用不同的哈希值计算方式。同一个资源，在两台服务端产生的 ETag 可能不同，对于使用服务器集群来处理请求的网站来说，使用 ETag 的缓存命中率会有所降低。

- ETag 优先级比 Last-Modified 高

### ServiceWorker

- ServiceWorker 是浏览器在后台独立于网页运行的脚本，主要功能是离线缓存，还可以实现推送通知、后台同步等功能。

- 使用限制：
1. 在 ServiceWorker 中无法访问 DOM，但可以通过 postMessage 与其控制的页面进行通信
2. ServiceWorker 只能在本地环境或 HTTPS 网站中使用
3. ServiceWorker 有作用域限制，一个 ServiceWorker 脚本只能作用域当前路径及其子路径
4. 存在兼容性问题

- 使用方法
1. 安装： `window.navigator.serviceWorker.register()`
2. 监听 install 事件
3. 拦截请求
