# 异步

## 异步和同步

同步调用函数的时候，会立即执行操作并等待返回结果后再继续执行，也就是说同步执行时阻塞的。

异步会将操作和结果在时间上分隔开来，立即执行操作，但在未来某个时刻才返回结果。也就是说异步执行时非阻塞的。

## 异步与回调

浏览器的 DOM 事件、AJAX 事件、定时器，Node.js的文件读写、多进程都是采用回调的形式。

并非所有的异步操作都是用回调的方式

## 事件循环

不同队列优先级不同，每次事件循环时会从优先级高的队列中获取事件，只有优先级高的队列为空时才会从优先级低的队列中获取事件，同级队列之间的事件不存在优先级，只遵循先进先出的原则。

## 异步串行

实现：

1. Promise.then

2. async/awiat(+ reduce)

## 异步并行

1. Promise.all()

返回一个新的 Promise 实例，如果所有 promise 都是成功的状态，返回所有结果；一旦出现失败的，立即抛出错误，错误原因是第一个失败的 promise 的原因

1. Promise.allSettled()

返回一个新的 Promise 实例，返回一个对象数组，每个对象表示对应的 promise 结果(包括status和value(或reason)两个属性)

1. Promise.race()

返回一个新的 promise 实例，一旦某个 promise 返回结果，就返回该 promise 的结果

## 异常处理

Promise 内部的异常不能在**外部**(内部可以)用 try/catch 捕获，当内部发生异常时，会自动进入失败状态

```js
try {
    new Promise((resolve, reject) => {
        throw new Error('自定义错误')
    })
} catch (err) {
    // 不会打印这句
    console.log('try catch 捕获了错误');
}
```

## Promise 的局限性

1. 当一个 Promise 实例被创建时，内部的代码会立即执行，而且无法从外部停止。比如无法取消超时或消耗性能的异步调用，容易导致资源的浪费。

2. 一个 Promise 实例只能 resolve 或 reject 一次，所以面对某些需要持续响应的场景时就会变得力不从心。比如上传文件获取进度时，默认采用的是通过事件监听的方式来实现。