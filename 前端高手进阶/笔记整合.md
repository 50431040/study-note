# html标签

## 自动刷新/跳转

```html
    <!-- 2s后跳转到jump页面 -->
    <meta http-equiv="Refresh" content="2; URL=jump.html">
```

```html
    <!-- 2s后自动刷新 -->
    <meta http-equiv="Refresh" content="2">
```

## 消息提醒

通过动态修改title

## 性能优化

1. script标签

若遇到 script 标签引用文件，则会暂停解析过程，同时通知网络线程加载文件，文件加载后会切换至 JavaScript 引擎来执行对应代码，代码执行完成之后切换至渲染引擎继续渲染页面。

- async：立即请求文件，不阻塞渲染引擎，在文件加载完毕后阻塞并立即执行。

- defer：立即请求，不阻塞，解析完HTML之后再执行文件内容。

- type为module：将文件当做模块进行解析，默认阻塞同defer，也可以配合async在请求完成后立即执行。

当渲染引擎解析 HTML 遇到 script 标签引入文件时，会立即进行一次渲染。如果是内联脚本（即不通过 src 属性引用外部脚本文件直接在 HTML 编写 JavaScript 代码的形式），渲染引擎则不会渲染。

2. link标签

- dns-refetch：浏览器对某个域名预先进行 DNS 解析并缓存。当浏览器在请求同域名资源的时候，能省去从域名查询 IP 的过程，从而减少时间损耗。

- preconnect：让浏览器在一个 HTTP 请求正式发给服务器前预先执行一些操作，这包括 DNS 解析、TLS 协商、TCP 握手，通过消除往返延迟来为用户节省时间。

- prefetch/preload：让浏览器预先下载并缓存某个资源，但不同的是，prefetch 可能会在浏览器忙时被忽略，而 preload 则是一定会被预先下载。

- prerender：浏览器不仅会加载资源，还会解析执行页面，进行预渲染。

![](https://s0.lgstatic.com/i/image/M00/07/0E/Ciqc1F647j-AFiBtAABWh7ld3uA965.png)

## 搜索优化

- meta标签

- link标签

```html
    <!-- 避免搜索引擎抓取重复页面 -->
    <link href="https://xx.com/a.html" rel="canonical">
```

## OGP协议

OGP 是 Facebook 公司在 2010 年提出的，目的是通过增加文档信息来提升社交网页在被分享时的预览效果。你只需要在一些分享页面中添加一些 meta 标签及属性，支持 OGP 协议的社交网站就会在解析页面时生成丰富的预览信息，比如站点名称、网页作者、预览图片。具体预览效果会因各个网站而有所变化。

# DOM节点

## 标签、DOM节点与元素

- 标签：HTML的基本单位，如p、div

- DOM节点：DOM树的基本单位，如注释节点、文本节点

- 元素节点：节点中的一种，与HTML标签所对应，如p标签对应p元素

举例：

```html
<!-- p是标签，生成DOM树的时候会产生两个节点，一个是元素节点p，另一个是文本节点123 -->
<p>123</p>
```

## DOM操作耗时

### 线程切换

浏览器包含了渲染引擎和JavaScript引擎，他们都是单线程运行。优势是开发方便，避免了多线程下的死锁、竞争等问题，劣势是失去了并发能力。

浏览器为了避免两个引擎同时修改页面而造成渲染结果不一致的情况，一个引擎运行时，另一个引擎会被阻塞。操作系统在进行线程切换的时候需要保存上一个线程执行时的状态信息并读取下一个线程的状态信息，俗称上下文切换。这个操作比较耗时。

每次 DOM 操作就会引发线程的上下文切换——从 JavaScript 引擎切换到渲染引擎执行对应操作，然后再切换回 JavaScript 引擎继续执行，这就带来了性能损耗。单次切换消耗的时间是非常少的，但是如果频繁的大量切换，那么就会产生性能问题。

### 重新渲染

浏览器在渲染页面时会将HTML和CSS分别解析为DOM树和CSSOM树，然后合并进行排布，再绘制成我们可见的页面。如果在操作DOM时涉及到元素、样式的修改，就会引起渲染引擎重新渲染。

- 重排(Reflow)

1. 修改元素边距、大小

2. 添加、删除元素

- 重绘(Repaint)

1. 改变字体颜色

2. 改变visibility

## 高效操作DOM

### 循环外操作元素

```js
// 
const body = document.body
for(let i = 0; i < 10000; i++) {
    // console.log(document.body)
    console.log(body)
}
```

### 批量操作元素

```js
// for (let i = 0; i < 10000; i++) {
//     document.appendChild(`<div>${i}</div>`)
// }
let el = ''
for(let i = 0; i < 10000; i++) {
    el += `<div>${i}</div>`
}
document.body.appendChild(el)
```

### 缓存元素集合

```js
// for (let i = 0; i < 10000; i++) {
//     document.querySelectorAll('div')[i].innerText = 1
// }
const els = document.querySelectorAll('div')
for(let i = 0; i < 10000; i++) {
    els[i].innerText = 1
}
```

# DOM事件

## 防抖

代码在同目录下

## 节流

## 代理

### 事件触发流程

捕获：事件对象 window 传播到目标的父对象

目标：事件对象到达事件对象的事件目标

冒泡：事件对象从目标的父节点开始传播到 window

## 监听方式

### 三种监听方式

1.

```html
<div type="text" onclick="handleClick()" ></div>
```

2.

```js
document.getElementById('div').onClick = function(e) {}
```

3.

```js
document.getElementById('div').addEventListener('click', function(e) {})
```

### 他们之间的区别

方式1和方式2同属于DOM0标准，通过这种方式进行事件监听会覆盖之前的事件监听函数。方式3属于DOM2标准，同一元素上的事件监听函数互不影响，而且可以独立取消，调用顺序和监听顺序一致。

# CSS（代码在同目录下）

## 单列布局

## 2列布局

宽度较小的列设置为固定宽度，剩余宽度另一列撑满。

## 3列布局

## 垂直方向的布局

将页面分为上、中、下三个部分，上、下部分都为固定高度，中间部分高度不定。当页面高度小于浏览器高度时，下部分应固定在屏幕底部；当页面高度超出浏览器高度时，下部分应该随中间部分被撑开，显示在页面最底部

## 框架中栅格布局的列数

首先从 12 列说起，12 这个数字，从数学上来说它具有很多约数 1、2、3、4、6、12，也就是说可以轻松实现 1 等分、2 等分、3 等分、4 等分、6 等分、12 等分，比例方面可以实现 1:11、1:5、1:3、1:2、1:1、1:10:1、1:4:1 等。如果换成 10 或 8，则可实现的等分比例就会少很多，而更大的 16 似乎是个不错的选择，但对于常用的 3 等分就难以实现。

至于使用 24 列不使用 12 列，可能是考虑宽屏幕（PC 端屏幕宽度不断增加）下对 12 列难以满足等分比例需求，比如 8 等分。同时又能够保证兼容 12 列情况下的等分比例（方便项目迁移和替换）。

# CSS

## BEM

BEM 是 Block、Element、Modifier 三个单词的缩写，Block 代表独立的功能组件，Element 代表功能组件的一个组成部分，Modifier 对应状态信息。例如 .button-state-success

## CSS Modules

借助 css Modules 插件，可以将 css 以 JSON 对象的形式引用和使用。

问题：在引用组件的同时，覆盖它的样式会变得困难，因为编译后的样式名是随机的。

## 高效复用样式

### 设置全局公共样式：

1. 具有枚举性的常用属性，如 display: inline-block; cursor: pointer。

2. 特定数值的样式属性值，如 margin: 0。

3. 设计规范所使用的属性

### 全局样式命名

属性名首字母 + 横线 + 属性值首字母

例如：display: inline-block 命名为 d-ib

## CSS in JavaScript

### 优点

- 可以通过随机命名解决作用域问题，但命名规则和 CSS Modules 都可以解决这个问题

- 样式可以使用 JavaScript 语言特性，比如函数、循环，实现元素不同的样式效果可以通过新建不同样式类，修改元素样式类来实现。

### 缺点

在编译后的样式代码中有很多重复的样式规则。这并不友好，不仅增加了编写样式的复杂度和代码量，连编译后也增加了冗余代码。

# 浏览器渲染页面

## HTML 到 DOM

1. 字节流解码

当浏览器得到字节数据后，通过“编码嗅探算法”来确定字符编码，然后根据字符编码将字节流数据进行解码。

2. 输入流预处理

通过上一步解码得到的字符流数据在进入解析环节之前还需要进行一些预处理操作。比如将换行符转换成统一的格式，最终生成规范化的字符流数据。

3. 令牌化

使用了一种类似状态机的算法，即每次接收一个或多个输入流中的字符；然后根据当前状态和这些字符来更新下一个状态，也就是说在不同的状态下接收同样的字符数据可能会产生不同的结果，比如当接收到“body”字符串时，在标签打开状态会解析成标签，在标签关闭状态则会解析成文本节点。

如果在 HTML 解析过程中遇到 script 标签，则会发生一些变化。
如果遇到的是内联代码，也就是在 script 标签中直接写代码，那么解析过程会暂停，执行权限会转给 JavaScript 脚本引擎，待 JavaScript 脚本执行完成之后再交由渲染引擎继续解析。有一种情况例外，那就是脚本内容中调用了改变 DOM 结构的 document.write() 函数，此时渲染引擎会回到第二步，将这些代码加入字符流，重新进行解析。

4. 构建 DOM 树

浏览器在创建解析器的同时会创建一个 Document 对象。在树构建阶段，Document 会作为根节点被不断地修改和扩充。标记步骤产生的令牌会被送到树构建器进行处理。HTML 5 标准中定义了每类令牌对应的 DOM 元素，当树构建器接收到某个令牌时就会创建该令牌对应的 DOM 元素并将该元素插入到 DOM 树中。

为了纠正元素标签嵌套错位的问题和处理未关闭的元素标签，树构建器创建的新 DOM 元素还会被插入到一个开放元素栈中。

渲染引擎除了解析 HTML 之外，也需要解析 CSS。

CSS 解析的过程与 HTML 解析过程步骤一致，最终也会生成树状结构。

与 DOM 树不同的是，CSSOM 树的节点具有继承特性，也就是会先继承父节点样式作为当前样式，然后再进行补充或覆盖。

5. 构建渲染树

从 DOM 树的根节点开始遍历，然后在 CSSOM 树上找到每个节点对应的样式。

遍历过程中会自动忽略那些不需要渲染的节点（比如脚本标记、元标记等）以及不可见的节点（比如设置了“display:none”样式）。同时也会将一些需要显示的伪类元素加到渲染树中。

6. 布局

布局就是计算元素的大小及位置。

布局完成后会输出对应的“盒模型”，它会精确地捕获每个元素的确切位置和大小，将所有相对值都转换为屏幕上的绝对像素。

7. 绘制

绘制就是将渲染树中的每个节点转换成屏幕上的实际像素的过程。

遍历布局树，生成绘制记录，然后渲染引擎会根据绘制记录去绘制相应的内容。

对于无动画效果的情况，只需要考虑空间维度，生成不同的图层，然后再把这些图层进行合成，最终成为我们看到的页面。当然这个绘制过程并不是静态不变的，会随着页面滚动不断合成新的图形。

## 总结

字节 → 字符 → 令牌 → 树 → 页面

# 数据类型

- 基本类型

null undefined number string boolean symbol

- 引用类型

object

## undefined

### 获取方式

- 已声明但未初始化

- 未定义的对象属性

- 执行无返回值的函数

- 执行 void 表达式

- 全局变量 window.undefined 或 undefined

推荐通过 void 表达式来得到 undefined 值，这种方式简便又不需要引用额外的变量，同时可以作为表达式配合三目运算符使用，代表不执行任何操作。

```js
i > 5 ? fn() : void 0
```

### 判断

```js
typeof x === 'undefined'
```

不能使用 x === undefined，如果 x 未定义会抛出错误 ’ReferenceError: x is not defined‘

## null

```js
null == undefined // true
```

null 是 JavaScript 保留关键字，而 undefined 只是一个常量。这意味着可以声明名称为 undefined 的变量，而 null 不能。

## boolean

注意：类型转换

```js
// 输入0时不会返回星期日
function getWeek(week) {
    const dict = ['日', '一', '二', '三', '四', '五', '六']
    if (week) return `星期${dict[week]}`
}
```

0 空字符串('') null undefined NaN 在转换时都会返回 false

## number

### 特殊值

1. NaN

```js
NaN === NaN // false
```

通常在计算失败的时候会得到该值。Number.isNaN()判断变量是否为NaN

2. Infinity

无穷大，某些场景下比较有用，比如用数值来表示权重或优先级，Infinity可以表示最高优先级

### 进制转换

```js
['0', '1', '2'].map(parseInt) // [0, NaN, NaN]
```

```js
10.toString(2) // '1010'
```

### 精度

```js
0.1 + 0.2 // 0.30000000000000004
Math.pow(Math.pow(5, 1/2), 2) // 5.000000000000001
```

#### 原因

出现这种情况的原因在于计算的时候，JavaScript 引擎会先将十进制转换为二进制，然后进行加法运算，再将结果转换为十进制。在进制转换的过程中如果小数位是无限的，就会出现误差。

#### 解决方案

1. 先转换为整数再计算，然后再将结果转换为小数。适合在小数位不是很多的时候，比如支付。

2. 使用 toPrecision 舍弃末尾的小数位

```js
parseFloat((0.1 + 0.2).toPrecision(12)) // 0.3
```

## string

### 千位分隔符的实现

1. 依次遍历

2. 正则

## Symbol

- 表示一个唯一的变量，创建时可以添加变量描述，该变量描述在传入时会被转换成字符串

- 避免常量值重复

- 避免对象属性覆盖

## 补充

- 把基本类型的数据转换成对应的对象过程称为"装箱转换"

- 把数据对象转换为基本类型的过程称为"拆箱转换"

- 以下常见操作会触发隐式地类型转换

1. 运算相关的操作符，包括 + - += ++ * / % << & 等

2. 数据比较相关的操作符，包括 > < == <= >= ===

3. 逻辑判断相关的操作符，包括 && ! || 三目运算符

## Object

### 深拷贝、浅拷贝

- 只传递指针为浅拷贝

- 创建一个新的与之相同的引用类型数据为深拷贝

### 实现深拷贝

- 使用 Object.getOwnPropertyNames() 和 Object.getOwnPropertySymbols() 获取键名，遍历递归。

- 避免循环：用 WeakMap 记录已经拷贝过的对象。（ WeakMap 的键是一个对象。）

# 函数

## this 关键字

- 一般指向调用它的对象。

首先 this 指向的应该是一个对象，更具体的说是函数执行的"上下文对象"。

其次这个对象指向的是"调用它"的对象，如果调用它的不是对象或对象不存在，则会执行全局对象(严格模式下为 undefined)

- forEach中的this指向

```js
const dx = {
    arr: [1]
}
// forEach的第二个参数为this值，默认为 undefined。every、find、findIndex、map、some也是如此
dx.arr.forEach(function() {
    console.log(this); // window
})

[0].forEach(function() {
    console.log(this); // 值为0的Number对象
}, 0)
```

- class 内部默认采用的是严格模式

```js
// class 内部默认采用的是严格模式
class B {
    fn() {
        console.log(this);
    }
}
const b = new B()
const fun = b.fn
fun() // undefined
```

- 箭头函数不会创建自己的this，只会从自己的作用域链的上一层继承this。

- 改变 this 指向的方法

```js
function getName() {
    console.log(this.name);
}
const b = getName.bind({
    name: 'bind'
})
b()
getName.call({
    name: 'call'
})
getName.apply({
    name: 'apply'
})
```

## 箭头函数

与普通函数相比，存在以下几个区别：

1. 函数内部不能访问 arguments 对象

2. 不能用作构造器，也就是不能通过关键字 new 来创建实例

3. 默认不会创建 prototype 原型属性

4. 不能用作 Generator() 函数，不能使用 yeild 关键字

## 函数转换

- toString() 函数会在打印函数的时候调用

- valueOf() 会在获取函数原始值时调用，比如加法操作

```js
function add(...args) {
    let arr = [...args]
    function fn(...newArgs) {
        arr = [...arr, ...newArgs]
        return fn
    }
    
    fn.toString = fn.valueOf = function() {
        return arr.reduce((pre, cur) => pre + cur)
    }

    return fn
}
console.log(add(1)); // 1
console.log(add(1)(2)); // 3
console.log(add(1, 2)(3, 4, 5)(6)); // 21
```

## 原型

- 原型就是对象的属性，包括被称为隐式原型的 __proto__ 属性和被称为显式原型的 prototype 属性

- 隐式原型通常在创建实例的时候会自动指向构造函数的显式原型

- 显式原型是内置函数的默认属性，在自定义函数时(箭头函数除外)也会默认生成，生成的显式原型对象只有一个属性 constructor，该属性指向函数自身。通常配合 new 关键字一起使用，当通过 new 创建函数实例时，会将实例的隐式原型指向构造函数的显式原型。

- 访问一个对象的属性，如果对象本身没有该属性，会沿着 __proto__ 依次向上找，这种类似递归的链式查找机制被称作"原型链"

## new的实现

1. 创建一个临时的空对象，让对象的隐式原型指向构造函数的显式原型

2. 执行构造函数，将this指向空对象，并传入参数，得到执行结果

3. 判断上一步的执行结果，如果为非空对象，则返回，否则返回构造函数

## 多层继承

假设构造函数 B 需要继承构造函数 A，就可以通过将函数 B 的显式原型指向一个函数 A 的实例，然后再对 B 的显式原型进行扩展(回填constructor)。

## typeof

可能出现的值：undefined、boolean、number、bigint、string、symbol、function、object

## instanceof

用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。

## 作用域

- 浏览器会自动将未主动声明的变量提升到全局作用域，Node.js需要显式的挂载到 global 对象上。

- 在类型上可以分为全局作用域、块级作用域、模块作用域

## 命名提升

对于使用 var 关键字声明的变量以及创建命名函数时，JavaScript 在解释执行的时候都会将其声明内容提升到作用域顶部，这种机制称为"命名提升"

## 闭包

在函数内部访问外部函数作用域时就会产生闭包

# 异步

## 异步和同步

同步调用函数的时候，会立即执行操作并等待返回结果后再继续执行，也就是说同步执行时阻塞的。

异步会将操作和结果在时间上分隔开来，立即执行操作，但在未来某个时刻才返回结果。也就是说异步执行时非阻塞的。

## 异步与回调

浏览器的 DOM 事件、AJAX 事件、定时器，Node.js的文件读写、多进程都是采用回调的形式。

并非所有的异步操作都是用回调的方式

## 事件循环

不同队列优先级不同，每次事件循环时会从优先级高的队列中获取事件，只有优先级高的队列为空时才会从优先级低的队列中获取事件，同级队列之间的事件不存在优先级，只遵循先进先出的原则。

## 异步串行

实现：

1. Promise.then

2. async/await(+ reduce)

## 异步并行

1. Promise.all()

返回一个新的 Promise 实例，如果所有 promise 都是成功的状态，返回所有结果；一旦出现失败的，立即抛出错误，错误原因是第一个失败的 promise 的原因

2. Promise.allSettled()

返回一个新的 Promise 实例，返回一个对象数组，每个对象表示对应的 promise 结果(包括status和value(或reason)两个属性)

3. Promise.race()

返回一个新的 promise 实例，一旦某个 promise 返回结果，就返回该 promise 的结果

## 异常处理

Promise 内部的异常不能在**外部**(内部可以)用 try/catch 捕获，当内部发生异常时，会自动进入失败状态

```js
try {
    new Promise((resolve, reject) => {
        throw new Error('自定义错误')
    })
} catch (err) {
    // 不会打印这句
    console.log('try catch 捕获了错误');
}
```

## Promise 的局限性

1. 当一个 Promise 实例被创建时，内部的代码会立即执行，而且无法从外部停止。比如无法取消超时或消耗性能的异步调用，容易导致资源的浪费。

2. 一个 Promise 实例只能 resolve 或 reject 一次，所以面对某些需要持续响应的场景时就会变得力不从心。比如上传文件获取进度时，默认采用的是通过事件监听的方式来实现。

# 模块化

## ES6 模块

1. ES6 模块强制自动采用严格模式。

2. 需要在 script 标签中将属性 type 值设置为 `module` 才能正确地被解析为 ES6 模块。

3. 在 Node.js 下使用 ES6 模块需要将文件名后缀改为 `.mjs`。

### 特性

- 值引用

**export** 语句输出的接口，与其对应的值是动态绑定关系。即通过该接口，可以取到模块内部实时的值，可以简单地理解为浅拷贝。

- 静态声明

不需要执行代码，只从字面量上对代码进行分析。方便优化代码体积，可以通过 `tree-shaking` 操作消除模块中没有被引入或者执行结果不会被用到的无用代码。

## CommonJS

### 定义和引用

规定每个文件就是一个模块，有独立的作用域。每个模块内部，都有一个 `module` 对象，通过它来导出 API，它有以下属性：

- id 模块识别符

- filename 模块文件名

- loaded 返回一个布尔值，表示是否已经完成加载

- parent 返回一个对象，表示调用该模块的模块

- children 返回一个数组，表示该模块要用到的其他模块

- exports 表示模块对外输出的值

引用模块则需要通过 `require` 函数，读入并并执行一个 `JavaScript` 文件，然后返回该模块的 `exports` 对象。

### 特性

- 值拷贝

和值引用相反，一旦输出一个值，模块内部的变化就影响不到这个值了，可以简单地理解为变量深拷贝。

- 动态声明

可以自由地在表达式语句中引用模块。

## AMD

### 定义和引用

只定义了一个全局函数 `define`，通过它就可以定义和引用模块。

```js
define(id?, dependencies?, factory)
```

id => 模块名称，默认为加载器请求的指定脚本的名字。dependencies => 数组，定义所依赖的模块。依赖模块必须根据模块的工厂函数优先级执行，并且执行的结果应该按照依赖数组中的位置顺序以参数的形式传入工厂函数中。factory => 模块初始化要执行的函数或对象。如果为函数，那么该函数只会执行一次。如果是对象，此对象为模块的输出值。

### 特性

异步加载，指的是同时并发加载所依赖的模块，当所有依赖模块都加载完成后，再执行当前模块的回调函数。这种加载方式和浏览器环境的性能需求刚好吻合。由于 AMD 并不是浏览器原生支持的模块规范，所以需要借助第三方库实现，其中最有名的就是 `RequireJS`。

## CMD

### 定义和引用

同样通过一个全局函数 `define` 实现，但只有一个参数，该参数既可以是函数也可以是对象。

```js
define(factory)

define(function(require, exports, module) {})
```

如果参数是对象，那么模块导出的就是对象。如果参数是函数，那么这个函数会被传入三个参数：require、exports 和 module。

require => 函数，用来引用其他模块，也可以调用 `require.async` 函数来异步调用模块。exports => 对象，当定义模块时，通过向其添加属性来导出模块。module => 对象，包括三个属性：uri，模块完整的 URI 路径。dependencies，模块的依赖。exports，需要被导出的 API，作用同 `exports`。

### 特性

懒加载。不需要在定义模块时就声明依赖，可以在执行时动态加载模块。但是 CMD 同时支持同步和异步加载模块。

## UMD

通过 UMD 可以在合适的环境选择对应的模块规范。比如在 Node.js 换将中采用 CommonJS 模块，在浏览器端且支持 AMD 的情况下采用 AMD 模块，否则导出为全局函数。

实现原理：

- 判断 `exports` 是否存在，存在则使用 Node.js 模块格式。

- 判断 `define` 是否存在，存在则使用 AMD 方式。

- 若两个都不存在，则将模块公开到全局（Window 或 Global）。


# TypeScript

## 类型与接口

### 元组

可以看成具有固定长度的数组，其中的数组元素类型可以不同。

```js
let x: [string, number]
```

### 枚举

带有名字的变量，可以分为数字枚举、字符串枚举和异构枚举。

### any

代表可以是任何一种类型，会跳过类型检查，相当于又成了弱类型。

### void

表示没有任何类型，常用于描述无返回值的函数。

### never

表示用于永远不会发生的值类型，一般用作执行不到 return 的函数返回值类型。

## 类型抽象

泛型是对类型的一种抽象，常用于函数，能让调用者动态地指定部分数据类型，可以对函数成员或类成员产生约束关系。

## 类型组合

### 交叉

将多个类型合并为一个类型，操作符为 `&`。

### 联合

多种类型中的任意一个，操作符为 `|`。

## 类型引用

### 索引

索引类型查询：`K extends keyof T`，索引类型访问：`T[K]`。

```js
function getValue<T, K extends keyof T>(o: T, name: K): T[K] {
    return o[name]; // o[name] is of type T[K]
}
let com = {
    name: 'lagou',
    id: 123
}
let id: number = getValue(com, 'id')
let no = getValue(com, 'no') //报错：Argument of type '"no"' is not assignable to parameter of type '"id" | "name"'.
```

### 映射

从已有类型中创建新的类型。

```js
type Pick<T, K extends keyof T> = {
  [P in K]: T[P];
};
interface task {
  title: string;
  description: string;
  status: string;
}
type simpleTask = Pick<task, 'title' | 'description'>// {title: string;description: string}
```

