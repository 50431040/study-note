# html标签

## 自动刷新/跳转

```html
    <!-- 2s后跳转到jump页面 -->
    <meta http-equiv="Refresh" content="2; URL=jump.html">
```

```html
    <!-- 2s后自动刷新 -->
    <meta http-equiv="Refresh" content="2">
```

## 消息提醒

通过动态修改title

## 性能优化

1. script标签

若遇到 script 标签引用文件，则会暂停解析过程，同时通知网络线程加载文件，文件加载后会切换至 JavaScript 引擎来执行对应代码，代码执行完成之后切换至渲染引擎继续渲染页面。

- async：立即请求文件，不阻塞渲染引擎，在文件加载完毕后阻塞并立即执行。

- defer：立即请求，不阻塞，解析完HTML之后再执行文件内容。

- type为module：将文件当做模块进行解析，默认阻塞同defer，也可以配合async在请求完成后立即执行。

当渲染引擎解析 HTML 遇到 script 标签引入文件时，会立即进行一次渲染。如果是内联脚本（即不通过 src 属性引用外部脚本文件直接在 HTML 编写 JavaScript 代码的形式），渲染引擎则不会渲染。

2. link标签

- dns-refetch：浏览器对某个域名预先进行 DNS 解析并缓存。当浏览器在请求同域名资源的时候，能省去从域名查询 IP 的过程，从而减少时间损耗。

- preconnect：让浏览器在一个 HTTP 请求正式发给服务器前预先执行一些操作，这包括 DNS 解析、TLS 协商、TCP 握手，通过消除往返延迟来为用户节省时间。

- prefetch/preload：让浏览器预先下载并缓存某个资源，但不同的是，prefetch 可能会在浏览器忙时被忽略，而 preload 则是一定会被预先下载。

- prerender：浏览器不仅会加载资源，还会解析执行页面，进行预渲染。

![](https://s0.lgstatic.com/i/image/M00/07/0E/Ciqc1F647j-AFiBtAABWh7ld3uA965.png)

## 搜索优化

- meta标签

- link标签

```html
    <!-- 避免搜索引擎抓取重复页面 -->
    <link href="https://xx.com/a.html" rel="canonical">
```

## OGP协议

OGP 是 Facebook 公司在 2010 年提出的，目的是通过增加文档信息来提升社交网页在被分享时的预览效果。你只需要在一些分享页面中添加一些 meta 标签及属性，支持 OGP 协议的社交网站就会在解析页面时生成丰富的预览信息，比如站点名称、网页作者、预览图片。具体预览效果会因各个网站而有所变化。

# DOM节点

## 标签、DOM节点与元素

- 标签：HTML的基本单位，如p、div

- DOM节点：DOM树的基本单位，如注释节点、文本节点

- 元素节点：节点中的一种，与HTML标签所对应，如p标签对应p元素

举例：

```html
<!-- p是标签，生成DOM树的时候会产生两个节点，一个是元素节点p，另一个是文本节点123 -->
<p>123</p>
```

## DOM操作耗时

### 线程切换

浏览器包含了渲染引擎和JavaScript引擎，他们都是单线程运行。优势是开发方便，避免了多线程下的死锁、竞争等问题，劣势是失去了并发能力。

浏览器为了避免两个引擎同时修改页面而造成渲染结果不一致的情况，一个引擎运行时，另一个引擎会被阻塞。操作系统在进行线程切换的时候需要保存上一个线程执行时的状态信息并读取下一个线程的状态信息，俗称上下文切换。这个操作比较耗时。

每次 DOM 操作就会引发线程的上下文切换——从 JavaScript 引擎切换到渲染引擎执行对应操作，然后再切换回 JavaScript 引擎继续执行，这就带来了性能损耗。单次切换消耗的时间是非常少的，但是如果频繁的大量切换，那么就会产生性能问题。

### 重新渲染

浏览器在渲染页面时会将HTML和CSS分别解析为DOM树和CSSOM树，然后合并进行排布，再绘制成我们可见的页面。如果在操作DOM时涉及到元素、样式的修改，就会引起渲染引擎重新渲染。

- 重排(Reflow)

1. 修改元素边距、大小

2. 添加、删除元素

- 重绘(Repaint)

1. 改变字体颜色

2. 改变visibility

## 高效操作DOM

### 循环外操作元素

```js
// 
const body = document.body
for(let i = 0; i < 10000; i++) {
    // console.log(document.body)
    console.log(body)
}
```

### 批量操作元素

```js
// for (let i = 0; i < 10000; i++) {
//     document.appendChild(`<div>${i}</div>`)
// }
let el = ''
for(let i = 0; i < 10000; i++) {
    el += `<div>${i}</div>`
}
document.body.appendChild(el)
```

### 缓存元素集合

```js
// for (let i = 0; i < 10000; i++) {
//     document.querySelectorAll('div')[i].innerText = 1
// }
const els = document.querySelectorAll('div')
for(let i = 0; i < 10000; i++) {
    els[i].innerText = 1
}
```

# DOM事件

## 防抖

代码在同目录下

## 节流

## 代理

### 事件触发流程

捕获：事件对象 window 传播到目标的父对象

目标：事件对象到达事件对象的事件目标

冒泡：事件对象从目标的父节点开始传播到 window

## 监听方式

### 三种监听方式

1.

```html
<div type="text" onclick="handleClick()" ></div>
```

2.

```js
document.getElementById('div').onClick = function(e) {}
```

3.

```js
document.getElementById('div').addEventListener('click', function(e) {})
```

### 他们之间的区别

方式1和方式2同属于DOM0标准，通过这种方式进行事件监听会覆盖之前的事件监听函数。方式3属于DOM2标准，同一元素上的事件监听函数互不影响，而且可以独立取消，调用顺序和监听顺序一致。

# CSS（代码在同目录下）

## 单列布局

## 2列布局

宽度较小的列设置为固定宽度，剩余宽度另一列撑满。

## 3列布局

## 垂直方向的布局

将页面分为上、中、下三个部分，上、下部分都为固定高度，中间部分高度不定。当页面高度小于浏览器高度时，下部分应固定在屏幕底部；当页面高度超出浏览器高度时，下部分应该随中间部分被撑开，显示在页面最底部

## 框架中栅格布局的列数

首先从 12 列说起，12 这个数字，从数学上来说它具有很多约数 1、2、3、4、6、12，也就是说可以轻松实现 1 等分、2 等分、3 等分、4 等分、6 等分、12 等分，比例方面可以实现 1:11、1:5、1:3、1:2、1:1、1:10:1、1:4:1 等。如果换成 10 或 8，则可实现的等分比例就会少很多，而更大的 16 似乎是个不错的选择，但对于常用的 3 等分就难以实现。

至于使用 24 列不使用 12 列，可能是考虑宽屏幕（PC 端屏幕宽度不断增加）下对 12 列难以满足等分比例需求，比如 8 等分。同时又能够保证兼容 12 列情况下的等分比例（方便项目迁移和替换）。

# CSS

## BEM

BEM 是 Block、Element、Modifier 三个单词的缩写，Block 代表独立的功能组件，Element 代表功能组件的一个组成部分，Modifier 对应状态信息。例如 .button-state-success

## CSS Modules

借助 css Modules 插件，可以将 css 以 JSON 对象的形式引用和使用。

问题：在引用组件的同时，覆盖它的样式会变得困难，因为编译后的样式名是随机的。

## 高效复用样式

### 设置全局公共样式：

1. 具有枚举性的常用属性，如 display: inline-block; cursor: pointer。

2. 特定数值的样式属性值，如 margin: 0。

3. 设计规范所使用的属性

### 全局样式命名

属性名首字母 + 横线 + 属性值首字母

例如：display: inline-block 命名为 d-ib

## CSS in JavaScript

### 优点

- 可以通过随机命名解决作用域问题，但命名规则和 CSS Modules 都可以解决这个问题

- 样式可以使用 JavaScript 语言特性，比如函数、循环，实现元素不同的样式效果可以通过新建不同样式类，修改元素样式类来实现。

### 缺点

在编译后的样式代码中有很多重复的样式规则。这并不友好，不仅增加了编写样式的复杂度和代码量，连编译后也增加了冗余代码。

# 浏览器渲染页面

## HTML 到 DOM

1. 字节流解码

当浏览器得到字节数据后，通过“编码嗅探算法”来确定字符编码，然后根据字符编码将字节流数据进行解码。

2. 输入流预处理

通过上一步解码得到的字符流数据在进入解析环节之前还需要进行一些预处理操作。比如将换行符转换成统一的格式，最终生成规范化的字符流数据。

3. 令牌化

使用了一种类似状态机的算法，即每次接收一个或多个输入流中的字符；然后根据当前状态和这些字符来更新下一个状态，也就是说在不同的状态下接收同样的字符数据可能会产生不同的结果，比如当接收到“body”字符串时，在标签打开状态会解析成标签，在标签关闭状态则会解析成文本节点。

如果在 HTML 解析过程中遇到 script 标签，则会发生一些变化。
如果遇到的是内联代码，也就是在 script 标签中直接写代码，那么解析过程会暂停，执行权限会转给 JavaScript 脚本引擎，待 JavaScript 脚本执行完成之后再交由渲染引擎继续解析。有一种情况例外，那就是脚本内容中调用了改变 DOM 结构的 document.write() 函数，此时渲染引擎会回到第二步，将这些代码加入字符流，重新进行解析。

4. 构建 DOM 树

浏览器在创建解析器的同时会创建一个 Document 对象。在树构建阶段，Document 会作为根节点被不断地修改和扩充。标记步骤产生的令牌会被送到树构建器进行处理。HTML 5 标准中定义了每类令牌对应的 DOM 元素，当树构建器接收到某个令牌时就会创建该令牌对应的 DOM 元素并将该元素插入到 DOM 树中。

为了纠正元素标签嵌套错位的问题和处理未关闭的元素标签，树构建器创建的新 DOM 元素还会被插入到一个开放元素栈中。

渲染引擎除了解析 HTML 之外，也需要解析 CSS。

CSS 解析的过程与 HTML 解析过程步骤一致，最终也会生成树状结构。

与 DOM 树不同的是，CSSOM 树的节点具有继承特性，也就是会先继承父节点样式作为当前样式，然后再进行补充或覆盖。

5. 构建渲染树

从 DOM 树的根节点开始遍历，然后在 CSSOM 树上找到每个节点对应的样式。

遍历过程中会自动忽略那些不需要渲染的节点（比如脚本标记、元标记等）以及不可见的节点（比如设置了“display:none”样式）。同时也会将一些需要显示的伪类元素加到渲染树中。

6. 布局

布局就是计算元素的大小及位置。

布局完成后会输出对应的“盒模型”，它会精确地捕获每个元素的确切位置和大小，将所有相对值都转换为屏幕上的绝对像素。

7. 绘制

绘制就是将渲染树中的每个节点转换成屏幕上的实际像素的过程。

遍历布局树，生成绘制记录，然后渲染引擎会根据绘制记录去绘制相应的内容。

对于无动画效果的情况，只需要考虑空间维度，生成不同的图层，然后再把这些图层进行合成，最终成为我们看到的页面。当然这个绘制过程并不是静态不变的，会随着页面滚动不断合成新的图形。

## 总结

字节 → 字符 → 令牌 → 树 → 页面

# 数据类型

- 基本类型

null undefined number string boolean symbol

- 引用类型

object

## undefined

### 获取方式

- 已声明但未初始化

- 未定义的对象属性

- 执行无返回值的函数

- 执行 void 表达式

- 全局变量 window.undefined 或 undefined

推荐通过 void 表达式来得到 undefined 值，这种方式简便又不需要引用额外的变量，同时可以作为表达式配合三目运算符使用，代表不执行任何操作。

```js
i > 5 ? fn() : void 0
```

### 判断

```js
typeof x === 'undefined'
```

不能使用 x === undefined，如果 x 未定义会抛出错误 ’ReferenceError: x is not defined‘

## null

```js
null == undefined // true
```

null 是 JavaScript 保留关键字，而 undefined 只是一个常量。这意味着可以声明名称为 undefined 的变量，而 null 不能。

## boolean

注意：类型转换

```js
// 输入0时不会返回星期日
function getWeek(week) {
    const dict = ['日', '一', '二', '三', '四', '五', '六']
    if (week) return `星期${dict[week]}`
}
```

0 空字符串('') null undefined NaN 在转换时都会返回 false

## number

### 特殊值

1. NaN

```js
NaN === NaN // false
```

通常在计算失败的时候会得到该值。Number.isNaN()判断变量是否为NaN

2. Infinity

无穷大，某些场景下比较有用，比如用数值来表示权重或优先级，Infinity可以表示最高优先级

### 进制转换

```js
['0', '1', '2'].map(parseInt) // [0, NaN, NaN]
```

```js
10.toString(2) // '1010'
```

### 精度

```js
0.1 + 0.2 // 0.30000000000000004
Math.pow(Math.pow(5, 1/2), 2) // 5.000000000000001
```

#### 原因

出现这种情况的原因在于计算的时候，JavaScript 引擎会先将十进制转换为二进制，然后进行加法运算，再将结果转换为十进制。在进制转换的过程中如果小数位是无限的，就会出现误差。

#### 解决方案

1. 先转换为整数再计算，然后再将结果转换为小数。适合在小数位不是很多的时候，比如支付。

2. 使用 toPrecision 舍弃末尾的小数位

```js
parseFloat((0.1 + 0.2).toPrecision(12)) // 0.3
```

## string

### 千位分隔符的实现

1. 依次遍历

2. 正则

## Symbol

- 表示一个唯一的变量，创建时可以添加变量描述，该变量描述在传入时会被转换成字符串

- 避免常量值重复

- 避免对象属性覆盖

## 补充

- 把基本类型的数据转换成对应的对象过程称为"装箱转换"

- 把数据对象转换为基本类型的过程称为"拆箱转换"

- 以下常见操作会触发隐式地类型转换

1. 运算相关的操作符，包括 + - += ++ * / % << & 等

2. 数据比较相关的操作符，包括 > < == <= >= ===

3. 逻辑判断相关的操作符，包括 && ! || 三目运算符

## Object

### 深拷贝、浅拷贝

- 只传递指针为浅拷贝

- 创建一个新的与之相同的引用类型数据为深拷贝

### 实现深拷贝

- 使用 Object.getOwnPropertyNames() 和 Object.getOwnPropertySymbols() 获取键名，遍历递归。

- 避免循环：用 WeakMap 记录已经拷贝过的对象。（ WeakMap 的键是一个对象。）

# 函数

## this 关键字

- 一般指向调用它的对象。

首先 this 指向的应该是一个对象，更具体的说是函数执行的"上下文对象"。

其次这个对象指向的是"调用它"的对象，如果调用它的不是对象或对象不存在，则会执行全局对象(严格模式下为 undefined)

- forEach中的this指向

```js
const dx = {
    arr: [1]
}
// forEach的第二个参数为this值，默认为 undefined。every、find、findIndex、map、some也是如此
dx.arr.forEach(function() {
    console.log(this); // window
})

[0].forEach(function() {
    console.log(this); // 值为0的Number对象
}, 0)
```

- class 内部默认采用的是严格模式

```js
// class 内部默认采用的是严格模式
class B {
    fn() {
        console.log(this);
    }
}
const b = new B()
const fun = b.fn
fun() // undefined
```

- 箭头函数不会创建自己的this，只会从自己的作用域链的上一层继承this。

- 改变 this 指向的方法

```js
function getName() {
    console.log(this.name);
}
const b = getName.bind({
    name: 'bind'
})
b()
getName.call({
    name: 'call'
})
getName.apply({
    name: 'apply'
})
```

## 箭头函数

与普通函数相比，存在以下几个区别：

1. 函数内部不能访问 arguments 对象

2. 不能用作构造器，也就是不能通过关键字 new 来创建实例

3. 默认不会创建 prototype 原型属性

4. 不能用作 Generator() 函数，不能使用 yeild 关键字

## 函数转换

- toString() 函数会在打印函数的时候调用

- valueOf() 会在获取函数原始值时调用，比如加法操作

```js
function add(...args) {
    let arr = [...args]
    function fn(...newArgs) {
        arr = [...arr, ...newArgs]
        return fn
    }
    
    fn.toString = fn.valueOf = function() {
        return arr.reduce((pre, cur) => pre + cur)
    }

    return fn
}
console.log(add(1)); // 1
console.log(add(1)(2)); // 3
console.log(add(1, 2)(3, 4, 5)(6)); // 21
```

## 原型

- 原型就是对象的属性，包括被称为隐式原型的 __proto__ 属性和被称为显式原型的 prototype 属性

- 隐式原型通常在创建实例的时候会自动指向构造函数的显式原型

- 显式原型是内置函数的默认属性，在自定义函数时(箭头函数除外)也会默认生成，生成的显式原型对象只有一个属性 constructor，该属性指向函数自身。通常配合 new 关键字一起使用，当通过 new 创建函数实例时，会将实例的隐式原型指向构造函数的显式原型。

- 访问一个对象的属性，如果对象本身没有该属性，会沿着 __proto__ 依次向上找，这种类似递归的链式查找机制被称作"原型链"

## new的实现

1. 创建一个临时的空对象，让对象的隐式原型指向构造函数的显式原型

2. 执行构造函数，将this指向空对象，并传入参数，得到执行结果

3. 判断上一步的执行结果，如果为非空对象，则返回，否则返回构造函数

## 多层继承

假设构造函数 B 需要继承构造函数 A，就可以通过将函数 B 的显式原型指向一个函数 A 的实例，然后再对 B 的显式原型进行扩展(回填constructor)。

## typeof

可能出现的值：undefined、boolean、number、bigint、string、symbol、function、object

## instanceof

用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。

## 作用域

- 浏览器会自动将未主动声明的变量提升到全局作用域，Node.js需要显式的挂载到 global 对象上。

- 在类型上可以分为全局作用域、块级作用域、模块作用域

## 命名提升

对于使用 var 关键字声明的变量以及创建命名函数时，JavaScript 在解释执行的时候都会将其声明内容提升到作用域顶部，这种机制称为"命名提升"

## 闭包

在函数内部访问外部函数作用域时就会产生闭包

# 异步

## 异步和同步

同步调用函数的时候，会立即执行操作并等待返回结果后再继续执行，也就是说同步执行时阻塞的。

异步会将操作和结果在时间上分隔开来，立即执行操作，但在未来某个时刻才返回结果。也就是说异步执行时非阻塞的。

## 异步与回调

浏览器的 DOM 事件、AJAX 事件、定时器，Node.js的文件读写、多进程都是采用回调的形式。

并非所有的异步操作都是用回调的方式

## 事件循环

不同队列优先级不同，每次事件循环时会从优先级高的队列中获取事件，只有优先级高的队列为空时才会从优先级低的队列中获取事件，同级队列之间的事件不存在优先级，只遵循先进先出的原则。

## 异步串行

实现：

1. Promise.then

2. async/await(+ reduce)

## 异步并行

1. Promise.all()

返回一个新的 Promise 实例，如果所有 promise 都是成功的状态，返回所有结果；一旦出现失败的，立即抛出错误，错误原因是第一个失败的 promise 的原因

2. Promise.allSettled()

返回一个新的 Promise 实例，返回一个对象数组，每个对象表示对应的 promise 结果(包括status和value(或reason)两个属性)

3. Promise.race()

返回一个新的 promise 实例，一旦某个 promise 返回结果，就返回该 promise 的结果

## 异常处理

Promise 内部的异常不能在**外部**(内部可以)用 try/catch 捕获，当内部发生异常时，会自动进入失败状态

```js
try {
    new Promise((resolve, reject) => {
        throw new Error('自定义错误')
    })
} catch (err) {
    // 不会打印这句
    console.log('try catch 捕获了错误');
}
```

## Promise 的局限性

1. 当一个 Promise 实例被创建时，内部的代码会立即执行，而且无法从外部停止。比如无法取消超时或消耗性能的异步调用，容易导致资源的浪费。

2. 一个 Promise 实例只能 resolve 或 reject 一次，所以面对某些需要持续响应的场景时就会变得力不从心。比如上传文件获取进度时，默认采用的是通过事件监听的方式来实现。

# 模块化

## ES6 模块

1. ES6 模块强制自动采用严格模式。

2. 需要在 script 标签中将属性 type 值设置为 `module` 才能正确地被解析为 ES6 模块。

3. 在 Node.js 下使用 ES6 模块需要将文件名后缀改为 `.mjs`。

### 特性

- 值引用

**export** 语句输出的接口，与其对应的值是动态绑定关系。即通过该接口，可以取到模块内部实时的值，可以简单地理解为浅拷贝。

- 静态声明

不需要执行代码，只从字面量上对代码进行分析。方便优化代码体积，可以通过 `tree-shaking` 操作消除模块中没有被引入或者执行结果不会被用到的无用代码。

## CommonJS

### 定义和引用

规定每个文件就是一个模块，有独立的作用域。每个模块内部，都有一个 `module` 对象，通过它来导出 API，它有以下属性：

- id 模块识别符

- filename 模块文件名

- loaded 返回一个布尔值，表示是否已经完成加载

- parent 返回一个对象，表示调用该模块的模块

- children 返回一个数组，表示该模块要用到的其他模块

- exports 表示模块对外输出的值

引用模块则需要通过 `require` 函数，读入并并执行一个 `JavaScript` 文件，然后返回该模块的 `exports` 对象。

### 特性

- 值拷贝

和值引用相反，一旦输出一个值，模块内部的变化就影响不到这个值了，可以简单地理解为变量深拷贝。

- 动态声明

可以自由地在表达式语句中引用模块。

## AMD

### 定义和引用

只定义了一个全局函数 `define`，通过它就可以定义和引用模块。

```js
define(id?, dependencies?, factory)
```

id => 模块名称，默认为加载器请求的指定脚本的名字。dependencies => 数组，定义所依赖的模块。依赖模块必须根据模块的工厂函数优先级执行，并且执行的结果应该按照依赖数组中的位置顺序以参数的形式传入工厂函数中。factory => 模块初始化要执行的函数或对象。如果为函数，那么该函数只会执行一次。如果是对象，此对象为模块的输出值。

### 特性

异步加载，指的是同时并发加载所依赖的模块，当所有依赖模块都加载完成后，再执行当前模块的回调函数。这种加载方式和浏览器环境的性能需求刚好吻合。由于 AMD 并不是浏览器原生支持的模块规范，所以需要借助第三方库实现，其中最有名的就是 `RequireJS`。

## CMD

### 定义和引用

同样通过一个全局函数 `define` 实现，但只有一个参数，该参数既可以是函数也可以是对象。

```js
define(factory)

define(function(require, exports, module) {})
```

如果参数是对象，那么模块导出的就是对象。如果参数是函数，那么这个函数会被传入三个参数：require、exports 和 module。

require => 函数，用来引用其他模块，也可以调用 `require.async` 函数来异步调用模块。exports => 对象，当定义模块时，通过向其添加属性来导出模块。module => 对象，包括三个属性：uri，模块完整的 URI 路径。dependencies，模块的依赖。exports，需要被导出的 API，作用同 `exports`。

### 特性

懒加载。不需要在定义模块时就声明依赖，可以在执行时动态加载模块。但是 CMD 同时支持同步和异步加载模块。

## UMD

通过 UMD 可以在合适的环境选择对应的模块规范。比如在 Node.js 换将中采用 CommonJS 模块，在浏览器端且支持 AMD 的情况下采用 AMD 模块，否则导出为全局函数。

实现原理：

- 判断 `exports` 是否存在，存在则使用 Node.js 模块格式。

- 判断 `define` 是否存在，存在则使用 AMD 方式。

- 若两个都不存在，则将模块公开到全局（Window 或 Global）。


# TypeScript

## 类型与接口

### 元组

可以看成具有固定长度的数组，其中的数组元素类型可以不同。

```js
let x: [string, number]
```

### 枚举

带有名字的变量，可以分为数字枚举、字符串枚举和异构枚举。

### any

代表可以是任何一种类型，会跳过类型检查，相当于又成了弱类型。

### void

表示没有任何类型，常用于描述无返回值的函数。

### never

表示用于永远不会发生的值类型，一般用作执行不到 return 的函数返回值类型。

## 类型抽象

泛型是对类型的一种抽象，常用于函数，能让调用者动态地指定部分数据类型，可以对函数成员或类成员产生约束关系。

## 类型组合

### 交叉

将多个类型合并为一个类型，操作符为 `&`。

### 联合

多种类型中的任意一个，操作符为 `|`。

## 类型引用

### 索引

索引类型查询：`K extends keyof T`，索引类型访问：`T[K]`。

```js
function getValue<T, K extends keyof T>(o: T, name: K): T[K] {
    return o[name]; // o[name] is of type T[K]
}
let com = {
    name: 'lagou',
    id: 123
}
let id: number = getValue(com, 'id')
let no = getValue(com, 'no') //报错：Argument of type '"no"' is not assignable to parameter of type '"id" | "name"'.
```

### 映射

从已有类型中创建新的类型。

```js
type Pick<T, K extends keyof T> = {
  [P in K]: T[P];
};
interface task {
  title: string;
  description: string;
  status: string;
}
type simpleTask = Pick<task, 'title' | 'description'>// {title: string;description: string}
```

# JavaScript 引擎

## 编译

- 解析

1. 词法分析

将 JavaScript 代码解析成一个个的令牌（Token）

2. 语法分析

将令牌组装成一棵抽象语法树（AST）

- 解释

通过解释器 Ignition 将 AST 转换成字节码。字节码是对机器码的一个抽象描述，相对于机器码而言，它的代码量更小，从而减少内存消耗。

- 优化

解释器得到 AST 后，会按需进行解释和执行。如果某个函数没有被调用，不会去解释执行它。在这个过程中，解释器会将一些重复可优化的操作收集起来生成分析数据，将生成的字节码和分析数据传给编译器 TurboFan，编译器会依据分析数据来生成高度优化的机器码。优化后的机器码的作用和缓存类似，当解释器再次遇到相同的内容就可以直接执行优化后的机器码。优化后的代码有可能无法运行（函数参数类型改变），那么会再次反优化为字节码交给解释器。

## 内存管理

分为堆和栈，堆是具有树结构的数组，栈也是数组，遵循“先进后出”。

### 栈

- 临时存储空间，主要存储局部变量和函数调用。对于基本类型的局部变量会直接在栈中创建，对象数据类型的局部变量会存储在堆中，栈只存储它的引用地址。全局变量以及闭包变量也是只存储引用地址。

- 对于函数，解释器创建了“调用栈”来记录函数的调用流程。每调用一个函数，解释器就会把该函数添加进调用栈，解释器会为被添加进的函数创建一个栈帧（Stack Frame，这个栈帧用来保存函数的局部变量以及执行语句）。如果正在执行的函数还调用了其他函数，那么新函数也将会被添加进调用栈并执行。一旦函数执行结束，对应的栈帧也会被立即摧毁。

- 查看调用栈：console.trace()、断点调试。

- 递归调用由于调用次数较多，同时每层函数调用都需要保存栈帧，所以比较消耗内存，对递归的优化一般有两个思路：减少递归次数和使用尾调用。

### 堆

堆空间大致分为五个区域：代码区、Map 区、大对象区、新生代、老生代。

- 新生代：大多数对象最开始都会分配在新生代，该存储空间相对较小，只有几十 MB，分为 from 空间和 to 空间。声明的对象首先会被分配到 from 空间，当进行垃圾回收时，会先将 from 空间存活的对象复制到 to 空间，对未存活的对象空间进行回收。复制完成后，from 空间和 to 空间进行调换。这种算法称之为 Scanvage。新生代的内存回收频率高，速度快，但控件利用率较低，因为一半的内存空间处于“闲置”状态。

- 老生代：新生代中多次回收仍然存活的对象会被转移到空间较大的老生代。老生代采用的是“标记清除”来回收未存活的对象空间。标记阶段会遍历堆中所有对象，并对存活的对象进行标记，清除阶段则对未标记对象的空间进行回收，在这之后会产生很多不连续的碎片控件。为了解决内存碎片的问题，提高内存的利用，需要使用标记整理算法，在回收阶段进行了改进，对于未标记的对象并不是立即回收，而是将存活的对象移到一边，然后再清理。但是这种移动操作比较耗时。

# 浏览器中的进程和线程

## 进程（Process）和线程（Thread）

- 进程是操作系统进行资源分配和调度的基本单位。

- 线程是操作系统进行运算的最小单位。

- 一个程序至少有一个进程，一个进程至少有一个线程。线程需要由进程来启动和管理。

- 不同进程之间的资源时独享的，不可用相互访问。这种特性带来的好处就是建立了进程之间的隔离性，避免了多个进程同时操作同一份数据而产生问题。

- 线程之间数据是共享的，也就意味着创建线程的成本更小，因为不需要分配额外的存储空间。进程中任意线程崩溃都会导致整个进程的崩溃。

- 多线程更轻量，多进程更安全稳定。

## 浏览器架构

### 浏览器进程

浏览器的主进程负责界面显示（地址栏、导航栏、书签等）、处理用户事件、管理子进程等。

### GPU 进程

可以利用 GPU 硬件来加速渲染，包括 Canvas 绘制、CSS3 转换（transitions）、CSS3 变换(transform)、WebGL 等。如果 DOM 元素使用了这些属性，GPU 进程就会在合成层的时候对它单独处理，提升到一个独立的层进行绘制，这样能避免重新布局和重新绘制。

### Network Service 进程

负责页面的网络资源加载。本来只是浏览器主进程的一个模块，现在为了将浏览器进程进行“服务化”，被抽取成了一个单独的进程。

### V8 代理解析工具进程

Chrome 支持使用 JavaScript 来写连接代理服务器脚本，称为 pac 代理脚本。解析 pac 脚本要用到 JavaScript 脚本引擎，直接在主进程中引入 JavaScript 引擎不符合“服务化”的设计理念，所以是一个单独的进程。

### 渲染进程

浏览器会为每个标签页单独启动一个渲染进程。所以和上面的不同，并不是只有一个。渲染进程的任务是将 HTML、CSS 和 JavaScript 转化为用户可以与之交互的网页，每个渲染进程都会启动单独的渲染引擎线程和 JavaScript 引擎线程。除此还包括事件触发线程，负责接收事件，并将回调函数放入 JavaScript 引擎线程的事件队列中，以及负责处理定时任务的定时器线程。保障了程序与系统的安全性，也保障了渲染进程的稳定性。

### 扩展程序进程

负责插件的运行，和渲染进程一样，也不是唯一的，会为每个插件都启动一个进程。

### 进程的服务化

Chrome 官方团队在 2016年 提出了面向服务的设计模型，在系统资源允许的情况下，将浏览器主进程的各种模块拆分成单独的服务，每个服务在单独的进程中运行。通过高内聚、低耦合的结构让 Chrome 更安全稳定。同时这种设计也具有一定的伸缩性，当运行在资源有限的设备上时，会将这些服务聚合到浏览器主进程中，从而减少内存占用。

# HTTP

## HTTP/0.9

协议定义了客户端发起请求、服务端响应请求的通信模式。请求报文内容只有 1 行，为 GET 加上请求的文件路径。服务端收到请求后返回一个以 ASCII 字符流编码的 HTML 文档。

## HTTP/1.0

增加了头部设定，头部内容以键值对的形式设置。请求头部通过 `Accept` 字段来告诉服务端可以接受的文件类型，响应头再通过 `Content-Type` 字段来告诉浏览器返回文件的类型。在此之上能够传输脚本、样式、图片等不同类型的文件。

## HTTP/1.1

- HTTP/1.0 每进行一次通信，都需要经历建立连接、传输数据和断开连接三个阶段，增加了网络开销。

- HTTP/1.1 增加了创建持久连接的方法，一个连接传输完成后，并不是马上关闭，而是继续复用来传输其他请求的数据，直到浏览器或者服务器要求断开连接为止。

### 三次握手

- 第一次握手：客户端处于 CLOSED 状态，服务端处于 LISTEN 状态。客户端给服务端发送一个 SYN 报文，并指明客户端的初始化序列号 ISN，此时客户端处于 SYN_SEND 状态。

- 第二次握手：当服务端收到客户端的 SYN 报文后，会以自己的 SYN 报文作为应答，并且制定自己的初始化序列号 ISN。同时会把客户端的 ISN + 1 作为 ACK 的值，表示已经收到了客户端的 SYN，此时服务端处于 SYN_REVD 状态。

- 第三次握手：当客户端收到 SYN 报文，把服务端的 ISN + 1 作为 ACK 发送给服务端，表示收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务端收到 ACK 报文后，也处于 ESTABLISHED 状态。此时双方成功建立起了连接。

- 为什么要进行三次握手？第一次握手让服务端知道了客户端具有发送能力，第二次握手让客户端知道了服务端具有接收和发送的能力，此时服务端不知道客户端是否接收到了自己发送的消息，所以第三次握手就起到了作用。

### 四次挥手

- 第一次挥手：客户端发送一个 FIN 报文，用来关闭客户端到服务端的数据传输，此时客户端处于 FIN_WAIT_1 状态。

- 第二次挥手：服务端收到 FIN ，会把客户端的序列号值加 1 作为 ACK 报文的序列号值发送给客户端，表示已经收到，此时服务端处于 CLOSE_WAIT 状态。

- 第三次挥手：如果服务端同意关闭连接，会向客户端发送一个 FIN 报文，并制定一个序列号，此时服务端处于 LAST_ACK 状态。

- 第四次挥手：客户端收到 ACK 后，处于 FIN_WAIT_2 状态。收到 FIN 报文时把服务端的序列号值加 1 作为 ACK 报文的序列号值发送给服务端。此时客户端处于 TIME_WAIT 装填。等待一段时间后进入 CLOSED 状态。当服务端收到 ACK 报文后，也变为 CLOSED 状态。此时连接正式关闭。

- 为什么建立连接只通信了三次，断开需要四次？因为当服务端收到客户端的 FIN 后， ACK 报文只是用来应答，并不表示服务端也希望立即关闭连接。当服务端把所有报文发送完了，才会发送 FIN 报文，告诉客户端可以断开连接了。

## HTTP/2

- HTTP/1.1 虽然通过长连接减少了大量创建/断开连接造成的损耗，但它的并发能力受到限制：浏览器为了减轻服务器的压力，限制了同一个域名下的 HTTP 连接数（6~8），使用多个域名来解决。使用持久连接时，多个请求复用一个 TCP 连接，但是一个连接中同一时刻只能处理一个请求，当前请求没有结束时，其他的请求处于阻塞状态，这种情况称为“队头阻塞”。

- HTTP/2 新增了一个二进制分帧的机制来提高传输效率。默认不再使用 ASCII 编码传世，改用二进制数据。发送请求时将每个请求的内容封装成不同的带有编号的二进制帧，然后将这些帧同时发送给服务端。服务端接收到数据之后，会将相同编号的帧合并为完整的请求信息。同样，服务端返回结果、客户端接收结果也遵循这个帧的拆分和组合的过程。这样，客户端只需要与客户端建立一个连接即可完成通信，不再受限于浏览器的连接数限制，利用一个连接来发送多个请求的方式称为“多路复用”。

## HTTPS

### 对称加密

### 非对称加密

### 证书机制

- 把公钥放入证书中，证书包含服务端的信息，比如颁发者、域名、有效期。为了确保证书是可信的，需要由 CA 对证书进行签名。如何检验证书签名的真假？证书签名就是将证书信息进行 MD5 计算，获取哈希值后利用私钥对其进行加密。校验就是用公钥对签名进行解密，将解密后的 MD5 值与计算所得的 MD5 值进行比对，如果两者一致代表签名是可信的。

- 通过签名来颁发和校验证书的方式会形成一个可追溯的链，即证书链。处于证书链顶端的证书称为根证书，这些根证书被预置在操作系统的内部。

## HTTP/3

HTTP/2 中，客户端或服务端在通信时出现数据包丢失，或者网络出现中断，整个 TCP 连接就会暂停。HTTP/3 将底层依赖的 TCP 改为 UDP，解决了这个问题。UDP 相对 TCP 而言最大的特点是传输数据时不需要建立连接，可以同时发送多个数据包，所以传输效率高，缺点是没有确认机制来保证对方一定能收到数据。

# 缓存

## 强制缓存

在浏览器加载资源时，先从缓存中查找，不存在再向服务端发起请求。

### Expires

- 设置缓存过期时间，是一个时间戳。

- 服务端和浏览器端的时间可能不一致，容易出现偏差。客户端可以通过修改系统时间来继续使用缓存或提前让缓存失效。

### Cache-Control

- 常用值：
1. no-cache 使用协商缓存，即每次使用缓存前必须向服务端确认缓存资源是否更新
2. no-store 禁止浏览器及所有中间缓存存储响应内容
3. public 公有缓存，表示可以被代理服务器缓存，可以被多个用户共享
4. private 私有缓存，不能被代理服务器缓存，不可用被多个用户共享
5. max-age 以秒为单位的数值，表示缓存的有效时间
6. must-revalidate 当缓存过期时，需要去服务端校验缓存的有效性

- 以上的值可以组合使用

- Cache-Control 的 `max-age` 优先级高于 Expires

## 协商缓存

发送请求到服务端进行确认缓存是否更新，返回 304 则表示缓存有效。

### Last-Modified 和 If-Modifiend-Since

- 工作流程：
1. 浏览器第一次请求资源，服务端在返回资源的响应头加上 `Last-Modified `字段，表示这个资源在服务端上的最近修改时间。
2. 当再次请求资源时，请求头部 `If-Modified-Since` 带上服务端返回的修改时间。
3. 服务端根据请求头判断资源是否变化，无变化返回 304 Not Modified，否则返回资源内容，且更新 Last-Modified 响应头。

- 问题：
1. 精度问题。时间精度为秒，在 1s 内发生修改，缓存判断会失效。
2. 准度问题。如果一个文件被修改，又被还原，内容没有发生变化，由于修改时间变化，缓存会失效。

### ETag 和 If-None-Match

- 不依赖于时间，依赖于文件哈希值。

- 具体流程：
1. 第一次请求资源，服务端在响应头中加入 ETag 字段
2. 再次请求时，在请求头中加上 `If-None-Match` 字段
3. 对比

- 问题：
1. 计算成本。生成哈希值相对于读取文件修改时间而言是一个开销较大的操作。尤其是对于大文件而言。如果要精确计算需要读取完整的文件内容，只读取部分内容又容易判断出错。
2. 计算误差。不同服务端可能采用不同的哈希值计算方式。同一个资源，在两台服务端产生的 ETag 可能不同，对于使用服务器集群来处理请求的网站来说，使用 ETag 的缓存命中率会有所降低。

- ETag 优先级比 Last-Modified 高

### ServiceWorker

- ServiceWorker 是浏览器在后台独立于网页运行的脚本，主要功能是离线缓存，还可以实现推送通知、后台同步等功能。

- 使用限制：
1. 在 ServiceWorker 中无法访问 DOM，但可以通过 postMessage 与其控制的页面进行通信
2. ServiceWorker 只能在本地环境或 HTTPS 网站中使用
3. ServiceWorker 有作用域限制，一个 ServiceWorker 脚本只能作用域当前路径及其子路径
4. 存在兼容性问题

- 使用方法
1. 安装： `window.navigator.serviceWorker.register()`
2. 监听 install 事件
3. 拦截请求
