# TypeScript

## 基础类型

1. boolean
2. number
3. string
4. 数组

- 数据类型后接上[]：number[]
- 数组泛型：Array<number>

5. 元组Tuple

- 允许表示一个一直元素数量和类型的**数组**，各元素的类型不必相同：[string, number]

- **当访问一个越界的元素，会使用联合类型替代**（但是，编辑器会报错）

6. enum

- 默认情况下，从**0**开始为元素编号，你也可以手动置顶成员的数值

- 可以由枚举的值得到它的名字

7. any

8. void

- 表示没有任何类型

- 只能赋值为`undefined`或`null`

9. null和undefined

是所有类型的子类型，可以把`null`和`undefined`赋值给其他类型的变量。但是，如果指定了 `--strictNullChecks` 标记，就只能赋值给 `void` 和它们各自。

10. never

- 表示那些永不存在的值的类型。例如，`never`类型是哪些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型

- 是任何类型的子类型。没有类型是`never`的子类型或可以赋值给`never`类型，即使`any`也不可以赋值给`never`

11. object

表示非原始类型，也就是除`number`、`string`、`boolean`、`symbol`、`null`或`undefined`之外的类型

### 类型断言

类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。

1. 尖括号

`(<string>someValue).length;`

2. as

`(someValue as string).length;`

## 变量声明

1. var

2. let

- 块级作用域、暂时性死区

- 不能在被声明之前读或写

- 仍然可以在一个拥有块作用域变量被声明前获取，只是不能再变量声明前去调用那个函数

3. const

### 解构

1. 数组解构

2. 对象解构

- 属性重命名

3. 默认值

`?:`

### 展开

1. 展开数组

2. 展开对象

- 对象展开还有其他一些意想不到的限制。首先，它仅包含对象自身的可枚举属性。大体上是说当你展开一个对象实例时，你会丢失其方法

## 接口

1. 可选属性

2. 只读属性

- readonly

- ReadonlyArray

数组创建后再也不能被修改

3. 额外的属性检查

```ts
interface SquareConfig {
    color?: string;
    width?: number;
    [propName: string]: any;
}
```

4. 函数类型

- 函数的参数名不需要与接口里定义的名字相匹配

5. 可索引的类型

- TS中支持两种索引签名：字符串和数字

- **数字索引的返回值必须是字符串索引返回值类型的子类型**。因为当使用`number`来索引时，会将它转换成`string`然后再去索引对象

```ts
interface StringArray {
  [index: number]: string;
}
```

6. 类类型

- 实现接口

- 类具有静态部分的类型和实例的类型，当用构造器签名去定义一个接口并试图定义一个类去实现这个接口时会得到一个错误

- 类实现一个接口时，只对其实例部分进行类型检查。`constructor`存在于类的静态部分，所以不在检查的范围内。

```ts
interface ClockConstructor {
  new (hour: number, minite: number);
}
// Error
class Clock2 implements ClockConstructor {
  constructor(h: number, m: number) {}
}
```

7. 继承接口

- 一个接口可以继承多个接口，创建出多个接口的合成接口。

8. **混合类型**

- 一个对象可以同时作为函数和对象使用，并带有额外的属性。

9. **接口继承类**

- 当接口继承了一个类类型时，它会继承类的成员但不包括其实现。接口会继承到类的`private`和`protected`成员。这意味着这个接口类型只能被这个类或其子类所实现。

## 类

1. 继承

- 在构造函数里访问`this`的属性之前，一定要调用`super()`

2. 公有、私有与受保护的修饰符

- 默认为`public`

- 当标记为`private`时，就不能在声明它的类的外部访问

- 比较两种不同的类型时，如果所有成员的类型都是兼容的，那么就认为它们的类型时兼容的。然而，当我们比较带有`private`或`protected`成员的类型时，如果其中一个类型里包含一个`private`成员，那么只有当另外一个类型中也存在这样一个`private`成员，并且它们都是来自同一处声明时，才认为这两个类型时兼容的。

- `protected`成员在派生类中仍然可以访问，外部仍然不能访问

- 构造函数也可以被标记成`protected`，这意味着这个类不能在包含它的类外被实例化，但是能被继承。

- 可以使用`readonly`关键字将属性设置为只读，只读属性必须在声明时或构造函数里被初始化

- 构造函数里使用`readonly`可以同时创建和初始化成员。

- 存取器（getter、setter）

- 静态成员存在于类本身上面而不是类的实例上

- 抽象类作为其他派生类的基类使用，不能被直接实例化。不同于接口，抽象类可以包含成员的实现细节。

- 抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。抽象方法必须包含`abstract`关键字并且可以包含访问修饰符。

- 可以把类当做接口使用