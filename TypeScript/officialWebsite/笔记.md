# TypeScript

## 基础类型

1. boolean
2. number
3. string
4. 数组

- 数据类型后接上[]：number[]
- 数组泛型：Array<number>

5. 元组Tuple

- 允许表示一个一直元素数量和类型的**数组**，各元素的类型不必相同：[string, number]

- **当访问一个越界的元素，会使用联合类型替代**（但是，编辑器会报错）

6. enum

- 默认情况下，从**0**开始为元素编号，你也可以手动置顶成员的数值

- 可以由枚举的值得到它的名字

7. any

8. void

- 表示没有任何类型

- 只能赋值为`undefined`或`null`

9. null和undefined

是所有类型的子类型，可以把`null`和`undefined`赋值给其他类型的变量。但是，如果指定了 `--strictNullChecks` 标记，就只能赋值给 `void` 和它们各自。

10. never

- 表示那些永不存在的值的类型。例如，`never`类型是哪些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型

- 是任何类型的子类型。没有类型是`never`的子类型或可以赋值给`never`类型，即使`any`也不可以赋值给`never`

11. object

表示非原始类型，也就是除`number`、`string`、`boolean`、`symbol`、`null`或`undefined`之外的类型

### 类型断言

类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。

1. 尖括号

`(<string>someValue).length;`

2. as

`(someValue as string).length;`

## 变量声明

1. var

2. let

- 块级作用域、暂时性死区

- 不能在被声明之前读或写

- 仍然可以在一个拥有块作用域变量被声明前获取，只是不能再变量声明前去调用那个函数

3. const

### 解构

1. 数组解构

2. 对象解构

- 属性重命名

3. 默认值

`?:`

### 展开

1. 展开数组

2. 展开对象

- 对象展开还有其他一些意想不到的限制。首先，它仅包含对象自身的可枚举属性。大体上是说当你展开一个对象实例时，你会丢失其方法

## 接口

1. 可选属性

2. 只读属性

- readonly

- ReadonlyArray

数组创建后再也不能被修改

3. 额外的属性检查

```ts
interface SquareConfig {
    color?: string;
    width?: number;
    [propName: string]: any;
}
```

4. 函数类型

- 函数的参数名不需要与接口里定义的名字相匹配

5. 可索引的类型

- TS中支持两种索引签名：字符串和数字

- **数字索引的返回值必须是字符串索引返回值类型的子类型**。因为当使用`number`来索引时，会将它转换成`string`然后再去索引对象

```ts
interface StringArray {
  [index: number]: string;
}
```

6. 类类型

- 实现接口

- 类具有静态部分的类型和实例的类型，当用构造器签名去定义一个接口并试图定义一个类去实现这个接口时会得到一个错误

- 类实现一个接口时，只对其实例部分进行类型检查。`constructor`存在于类的静态部分，所以不在检查的范围内。

```ts
interface ClockConstructor {
  new (hour: number, minite: number);
}
// Error
class Clock2 implements ClockConstructor {
  constructor(h: number, m: number) {}
}
```

7. 继承接口

- 一个接口可以继承多个接口，创建出多个接口的合成接口。

8. **混合类型**

- 一个对象可以同时作为函数和对象使用，并带有额外的属性。

9. **接口继承类**

- 当接口继承了一个类类型时，它会继承类的成员但不包括其实现。接口会继承到类的`private`和`protected`成员。这意味着这个接口类型只能被这个类或其子类所实现。

