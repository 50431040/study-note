# TypeScript

## 基础类型

1. boolean
2. number
3. string
4. 数组

- 数据类型后接上[]：number[]
- 数组泛型：Array<number>

5. 元组Tuple

- 允许表示一个一直元素数量和类型的**数组**，各元素的类型不必相同：[string, number]

- **当访问一个越界的元素，会使用联合类型替代**（但是，编辑器会报错）

6. enum

- 默认情况下，从**0**开始为元素编号，你也可以手动置顶成员的数值

- 可以由枚举的值得到它的名字

7. any

8. void

- 表示没有任何类型

- 只能赋值为`undefined`或`null`

9. null和undefined

是所有类型的子类型，可以把`null`和`undefined`赋值给其他类型的变量。但是，如果指定了 `--strictNullChecks` 标记，就只能赋值给 `void` 和它们各自。

10. never

- 表示那些永不存在的值的类型。例如，`never`类型是哪些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型

- 是任何类型的子类型。没有类型是`never`的子类型或可以赋值给`never`类型，即使`any`也不可以赋值给`never`

11. object

表示非原始类型，也就是除`number`、`string`、`boolean`、`symbol`、`null`或`undefined`之外的类型

### 类型断言

类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。

1. 尖括号

`(<string>someValue).length;`

2. as

`(someValue as string).length;`

## 变量声明

1. var

2. let

- 块级作用域、暂时性死区

- 不能在被声明之前读或写

- 仍然可以在一个拥有块作用域变量被声明前获取，只是不能再变量声明前去调用那个函数

3. const

### 解构

1. 数组解构

2. 对象解构

- 属性重命名

3. 默认值

`?:`

### 展开

1. 展开数组

2. 展开对象

- 对象展开还有其他一些意想不到的限制。首先，它仅包含对象自身的可枚举属性。大体上是说当你展开一个对象实例时，你会丢失其方法

## 接口

1. 可选属性

2. 只读属性

- readonly

- ReadonlyArray

数组创建后再也不能被修改

3. 额外的属性检查

```ts
interface SquareConfig {
    color?: string;
    width?: number;
    [propName: string]: any;
}
```

4. 函数类型

- 函数的参数名不需要与接口里定义的名字相匹配

5. 可索引的类型

- TS中支持两种索引签名：字符串和数字

- **数字索引的返回值必须是字符串索引返回值类型的子类型**。因为当使用`number`来索引时，会将它转换成`string`然后再去索引对象

```ts
interface StringArray {
  [index: number]: string;
}
```

6. 类类型

- 实现接口

- 类具有静态部分的类型和实例的类型，当用构造器签名去定义一个接口并试图定义一个类去实现这个接口时会得到一个错误

- 类实现一个接口时，只对其实例部分进行类型检查。`constructor`存在于类的静态部分，所以不在检查的范围内。

```ts
interface ClockConstructor {
  new (hour: number, minite: number);
}
// Error
class Clock2 implements ClockConstructor {
  constructor(h: number, m: number) {}
}
```

7. 继承接口

- 一个接口可以继承多个接口，创建出多个接口的合成接口。

8. **混合类型**

- 一个对象可以同时作为函数和对象使用，并带有额外的属性。

9. **接口继承类**

- 当接口继承了一个类类型时，它会继承类的成员但不包括其实现。接口会继承到类的`private`和`protected`成员。这意味着这个接口类型只能被这个类或其子类所实现。

## 类

1. 继承

- 在构造函数里访问`this`的属性之前，一定要调用`super()`

2. 公有、私有与受保护的修饰符

- 默认为`public`

- 当标记为`private`时，就不能在声明它的类的外部访问

- 比较两种不同的类型时，如果所有成员的类型都是兼容的，那么就认为它们的类型时兼容的。然而，当我们比较带有`private`或`protected`成员的类型时，如果其中一个类型里包含一个`private`成员，那么只有当另外一个类型中也存在这样一个`private`成员，并且它们都是来自同一处声明时，才认为这两个类型时兼容的。

- `protected`成员在派生类中仍然可以访问，外部仍然不能访问

- 构造函数也可以被标记成`protected`，这意味着这个类不能在包含它的类外被实例化，但是能被继承。

- 可以使用`readonly`关键字将属性设置为只读，只读属性必须在声明时或构造函数里被初始化

- 构造函数里使用`readonly`可以同时创建和初始化成员。

- 存取器（getter、setter）

- 静态成员存在于类本身上面而不是类的实例上

- 抽象类作为其他派生类的基类使用，不能被直接实例化。不同于接口，抽象类可以包含成员的实现细节。

- 抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。抽象方法必须包含`abstract`关键字并且可以包含访问修饰符。

- 可以把类当做接口使用

## 函数

1. 可选参数和默认参数

- 可选参数必须跟在必须参数后面

- 在所有必须参数后面的带默认初始化的参数都是可选的，与可选参数一样，在调用的时候可以忽略。

- 与普通可选参数不同的是，带默认值的参数不需要放在必须参数后面。如果带默认值的参数出现在必须参数前面，用户必须明确的传入`undefined`来获得默认值。

2. 剩余参数

3. this指向

4. 重载

- 根据传入不同的参数而返回不同类型的数据

- 为同一个函数提供多个函数类型定义来进行函数重载，编译器会根据这个列表去处理函数的调用。

## 泛型

1. 使用：

- 传入所有的参数，包含类型参数

- 只传入参数，编译器会根据传入的参数自动帮助我们确定T的类型

2. 在函数体必须正确的使用这个通过的类型，把这些参数当做是任意或所有类型

3. 泛型类型

- 可以使用不同的泛型参数名，只要在数量上和使用方式上能对应上就行

- 可以使用带有调用签名的对象字面量来定义泛型函数

4. 泛型接口

5. 把泛型参数当做整个接口的一个参数

6. 泛型类

- 无法创建泛型枚举和泛型命名空间

- 类的静态属性不能使用这个泛型类型

7. 泛型约束

- 可以定义一个接口来描述约束条件

- 可以声明一个类型参数，且它被另一个类型参数所约束

- 泛型里使用类类型

## 枚举

1. 数字枚举

- 自增长

2. 字符串枚举

- 每个成员都必须用字符串字面量，或另外一个字符串枚举成员进行初始化

3. 异构枚举

- 枚举可以混合字符串和数字成员

4. 计算的和常量成员

5. 联合枚举

- 枚举类型本身变成了每个枚举成员的联合

6. 运行时的枚举

- 枚举是在运行时真正存在的对象

- 除了创建一个以属性名作为对象成员的对象之外，数字枚举成员还具有了反向映射，从枚举值到枚举名字。但是不会为字符串枚举成员生成反向映射

7. const 枚举

- 常量枚举在编译阶段会被删除，在使用的地方会被内联进来。之所以可以这么做是因为，常量枚举不允许包含计算成员

8. 外部枚举

- 用来描述已经存在的枚举类型的形状

- 外部枚举和非外部枚举的区别是，在正常的枚举里，没有初始化方法的成员被当成常数成员。非常数的外部成员而言，没有初始化方法时被当做需要经过计算的。